<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>lib/socket.io.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/api.html">api</a></li>
                                <li><a href="../classes/Hashes.html">Hashes</a></li>
                                <li><a href="../classes/Hashes.html">Hashes</a></li>
                                <li><a href="../classes/Hashes.html">Hashes</a></li>
                                <li><a href="../classes/Hashes.html">Hashes</a></li>
                                <li><a href="../classes/Hashes.html">Hashes</a></li>
                                <li><a href="../classes/Hashes.html">Hashes</a></li>
                                <li><a href="../classes/Hashes.RMD160.html">Hashes.RMD160</a></li>
                                <li><a href="../classes/Hashes.SHA256.html">Hashes.SHA256</a></li>
                                <li><a href="../classes/Hashes.SHA512.html">Hashes.SHA512</a></li>
                                <li><a href="../classes/.html"></a></li>
                                <li><a href="../classes/Popper.modifiers.fecha.html">Popper.modifiers.fecha</a></li>
                                <li><a href="../classes/Popper.modifiers.Hashes.RMD160.html">Popper.modifiers.Hashes.RMD160</a></li>
                                <li><a href="../classes/Popper.modifiers.Hashes.SHA256.html">Popper.modifiers.Hashes.SHA256</a></li>
                                <li><a href="../classes/Popper.modifiers.Hashes.SHA512.html">Popper.modifiers.Hashes.SHA512</a></li>
                                <li><a href="../classes/ReactClass.html">ReactClass</a></li>
                                <li><a href="../classes/ReactDOMTextComponent.html">ReactDOMTextComponent</a></li>
                                <li><a href="../classes/ReactMountReady.html">ReactMountReady</a></li>
                                <li><a href="../classes/ReactMultiChild.html">ReactMultiChild</a></li>
                                <li><a href="../classes/ReactOwner.html">ReactOwner</a></li>
                                <li><a href="../classes/ReactPropTransferer.html">ReactPropTransferer</a></li>
                                <li><a href="../classes/ReactReconcileTransaction.html">ReactReconcileTransaction</a></li>
                                <li><a href="../classes/ReactServerRenderingTransaction.html">ReactServerRenderingTransaction</a></li>
                                <li><a href="../classes/ReactShallowRenderer.html">ReactShallowRenderer</a></li>
                                <li><a href="../classes/ReactTestUtils.html">ReactTestUtils</a></li>
                                <li><a href="../classes/state.html">state</a></li>
                                <li><a href="../classes/Transaction.html">Transaction</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/Api.html">Api</a></li>
                                <li><a href="../modules/Store.html">Store</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: lib/socket.io.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
 * Created by user on 2017/2/6.
 */
(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.io = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#x27;&quot;+o+&quot;&#x27;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){

  module.exports =  _dereq_(&#x27;./lib/&#x27;);

},{&quot;./lib/&quot;:2}],2:[function(_dereq_,module,exports){

  module.exports = _dereq_(&#x27;./socket&#x27;);

  /**
   * Exports parser
   *
   * @api public
   *
   */
  module.exports.parser = _dereq_(&#x27;engine.io-parser&#x27;);

},{&quot;./socket&quot;:3,&quot;engine.io-parser&quot;:19}],3:[function(_dereq_,module,exports){
  (function (global){
    /**
     * Module dependencies.
     */

    var transports = _dereq_(&#x27;./transports&#x27;);
    var Emitter = _dereq_(&#x27;component-emitter&#x27;);
    var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:socket&#x27;);
    var index = _dereq_(&#x27;indexof&#x27;);
    var parser = _dereq_(&#x27;engine.io-parser&#x27;);
    var parseuri = _dereq_(&#x27;parseuri&#x27;);
    var parsejson = _dereq_(&#x27;parsejson&#x27;);
    var parseqs = _dereq_(&#x27;parseqs&#x27;);

    /**
     * Module exports.
     */

    module.exports = Socket;

    /**
     * Noop function.
     *
     * @api private
     */

    function noop(){}

    /**
     * Socket constructor.
     *
     * @param {String|Object} uri or options
     * @param {Object} options
     * @api public
     */

    function Socket(uri, opts){
      if (!(this instanceof Socket)) return new Socket(uri, opts);

      opts = opts || {};

      if (uri &amp;&amp; &#x27;object&#x27; == typeof uri) {
        opts = uri;
        uri = null;
      }

      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol == &#x27;https&#x27; || uri.protocol == &#x27;wss&#x27;;
        opts.port = uri.port;
        if (uri.query) opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }

      this.secure = null != opts.secure ? opts.secure :
        (global.location &amp;&amp; &#x27;https:&#x27; == location.protocol);

      if (opts.hostname &amp;&amp; !opts.port) {
        // if no port is specified manually, use the protocol default
        opts.port = this.secure ? &#x27;443&#x27; : &#x27;80&#x27;;
      }

      this.agent = opts.agent || false;
      this.hostname = opts.hostname ||
        (global.location ? location.hostname : &#x27;localhost&#x27;);
      this.port = opts.port || (global.location &amp;&amp; location.port ?
          location.port :
          (this.secure ? 443 : 80));
      this.query = opts.query || {};
      if (&#x27;string&#x27; == typeof this.query) this.query = parseqs.decode(this.query);
      this.upgrade = false !== opts.upgrade;
      this.path = (opts.path || &#x27;/engine.io&#x27;).replace(/\/$/, &#x27;&#x27;) + &#x27;/&#x27;;
      this.forceJSONP = !!opts.forceJSONP;
      this.jsonp = false !== opts.jsonp;
      this.forceBase64 = !!opts.forceBase64;
      this.enablesXDR = !!opts.enablesXDR;
      this.timestampParam = opts.timestampParam || &#x27;t&#x27;;
      this.timestampRequests = opts.timestampRequests;
      this.transports = opts.transports || [&#x27;polling&#x27;, &#x27;websocket&#x27;];
      this.readyState = &#x27;&#x27;;
      this.writeBuffer = [];
      this.policyPort = opts.policyPort || 843;
      this.rememberUpgrade = opts.rememberUpgrade || false;
      this.binaryType = null;
      this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
      this.perMessageDeflate = false !== opts.perMessageDeflate ? (opts.perMessageDeflate || {}) : false;

      if (true === this.perMessageDeflate) this.perMessageDeflate = {};
      if (this.perMessageDeflate &amp;&amp; null == this.perMessageDeflate.threshold) {
        this.perMessageDeflate.threshold = 1024;
      }

      // SSL options for Node.js client
      this.pfx = opts.pfx || null;
      this.key = opts.key || null;
      this.passphrase = opts.passphrase || null;
      this.cert = opts.cert || null;
      this.ca = opts.ca || null;
      this.ciphers = opts.ciphers || null;
      this.rejectUnauthorized = opts.rejectUnauthorized === undefined ? true : opts.rejectUnauthorized;

      // other options for Node.js client
      var freeGlobal = typeof global == &#x27;object&#x27; &amp;&amp; global;
      if (freeGlobal.global === freeGlobal) {
        if (opts.extraHeaders &amp;&amp; Object.keys(opts.extraHeaders).length &gt; 0) {
          this.extraHeaders = opts.extraHeaders;
        }
      }

      this.open();
    }

    Socket.priorWebsocketSuccess = false;

    /**
     * Mix in &#x60;Emitter&#x60;.
     */

    Emitter(Socket.prototype);

    /**
     * Protocol version.
     *
     * @api public
     */

    Socket.protocol = parser.protocol; // this is an int

    /**
     * Expose deps for legacy compatibility
     * and standalone browser access.
     */

    Socket.Socket = Socket;
    Socket.Transport = _dereq_(&#x27;./transport&#x27;);
    Socket.transports = _dereq_(&#x27;./transports&#x27;);
    Socket.parser = _dereq_(&#x27;engine.io-parser&#x27;);

    /**
     * Creates transport of the given type.
     *
     * @param {String} transport name
     * @return {Transport}
     * @api private
     */

    Socket.prototype.createTransport = function (name) {
      debug(&#x27;creating transport &quot;%s&quot;&#x27;, name);
      var query = clone(this.query);

      // append engine.io protocol identifier
      query.EIO = parser.protocol;

      // transport name
      query.transport = name;

      // session id if we already have one
      if (this.id) query.sid = this.id;

      var transport = new transports[name]({
        agent: this.agent,
        hostname: this.hostname,
        port: this.port,
        secure: this.secure,
        path: this.path,
        query: query,
        forceJSONP: this.forceJSONP,
        jsonp: this.jsonp,
        forceBase64: this.forceBase64,
        enablesXDR: this.enablesXDR,
        timestampRequests: this.timestampRequests,
        timestampParam: this.timestampParam,
        policyPort: this.policyPort,
        socket: this,
        pfx: this.pfx,
        key: this.key,
        passphrase: this.passphrase,
        cert: this.cert,
        ca: this.ca,
        ciphers: this.ciphers,
        rejectUnauthorized: this.rejectUnauthorized,
        perMessageDeflate: this.perMessageDeflate,
        extraHeaders: this.extraHeaders
      });

      return transport;
    };

    function clone (obj) {
      var o = {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = obj[i];
        }
      }
      return o;
    }

    /**
     * Initializes transport to use and starts probe.
     *
     * @api private
     */
    Socket.prototype.open = function () {
      var transport;
      if (this.rememberUpgrade &amp;&amp; Socket.priorWebsocketSuccess &amp;&amp; this.transports.indexOf(&#x27;websocket&#x27;) != -1) {
        transport = &#x27;websocket&#x27;;
      } else if (0 === this.transports.length) {
        // Emit error on next tick so it can be listened to
        var self = this;
        setTimeout(function() {
          self.emit(&#x27;error&#x27;, &#x27;No transports available&#x27;);
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = &#x27;opening&#x27;;

      // Retry with the next transport if the transport is disabled (jsonp: false)
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        this.transports.shift();
        this.open();
        return;
      }

      transport.open();
      this.setTransport(transport);
    };

    /**
     * Sets the current transport. Disables the existing one (if any).
     *
     * @api private
     */

    Socket.prototype.setTransport = function(transport){
      debug(&#x27;setting transport %s&#x27;, transport.name);
      var self = this;

      if (this.transport) {
        debug(&#x27;clearing existing transport %s&#x27;, this.transport.name);
        this.transport.removeAllListeners();
      }

      // set up transport
      this.transport = transport;

      // set up transport listeners
      transport
        .on(&#x27;drain&#x27;, function(){
          self.onDrain();
        })
        .on(&#x27;packet&#x27;, function(packet){
          self.onPacket(packet);
        })
        .on(&#x27;error&#x27;, function(e){
          self.onError(e);
        })
        .on(&#x27;close&#x27;, function(){
          self.onClose(&#x27;transport close&#x27;);
        });
    };

    /**
     * Probes a transport.
     *
     * @param {String} transport name
     * @api private
     */

    Socket.prototype.probe = function (name) {
      debug(&#x27;probing transport &quot;%s&quot;&#x27;, name);
      var transport = this.createTransport(name, { probe: 1 })
        , failed = false
        , self = this;

      Socket.priorWebsocketSuccess = false;

      function onTransportOpen(){
        if (self.onlyBinaryUpgrades) {
          var upgradeLosesBinary = !this.supportsBinary &amp;&amp; self.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed) return;

        debug(&#x27;probe transport &quot;%s&quot; opened&#x27;, name);
        transport.send([{ type: &#x27;ping&#x27;, data: &#x27;probe&#x27; }]);
        transport.once(&#x27;packet&#x27;, function (msg) {
          if (failed) return;
          if (&#x27;pong&#x27; == msg.type &amp;&amp; &#x27;probe&#x27; == msg.data) {
            debug(&#x27;probe transport &quot;%s&quot; pong&#x27;, name);
            self.upgrading = true;
            self.emit(&#x27;upgrading&#x27;, transport);
            if (!transport) return;
            Socket.priorWebsocketSuccess = &#x27;websocket&#x27; == transport.name;

            debug(&#x27;pausing current transport &quot;%s&quot;&#x27;, self.transport.name);
            self.transport.pause(function () {
              if (failed) return;
              if (&#x27;closed&#x27; == self.readyState) return;
              debug(&#x27;changing transport and sending upgrade packet&#x27;);

              cleanup();

              self.setTransport(transport);
              transport.send([{ type: &#x27;upgrade&#x27; }]);
              self.emit(&#x27;upgrade&#x27;, transport);
              transport = null;
              self.upgrading = false;
              self.flush();
            });
          } else {
            debug(&#x27;probe transport &quot;%s&quot; failed&#x27;, name);
            var err = new Error(&#x27;probe error&#x27;);
            err.transport = transport.name;
            self.emit(&#x27;upgradeError&#x27;, err);
          }
        });
      }

      function freezeTransport() {
        if (failed) return;

        // Any callback called by transport should be ignored since now
        failed = true;

        cleanup();

        transport.close();
        transport = null;
      }

      //Handle any error that happens while probing
      function onerror(err) {
        var error = new Error(&#x27;probe error: &#x27; + err);
        error.transport = transport.name;

        freezeTransport();

        debug(&#x27;probe transport &quot;%s&quot; failed because of error: %s&#x27;, name, err);

        self.emit(&#x27;upgradeError&#x27;, error);
      }

      function onTransportClose(){
        onerror(&quot;transport closed&quot;);
      }

      //When the socket is closed while we&#x27;re probing
      function onclose(){
        onerror(&quot;socket closed&quot;);
      }

      //When the socket is upgraded while we&#x27;re probing
      function onupgrade(to){
        if (transport &amp;&amp; to.name != transport.name) {
          debug(&#x27;&quot;%s&quot; works - aborting &quot;%s&quot;&#x27;, to.name, transport.name);
          freezeTransport();
        }
      }

      //Remove all listeners on the transport and on self
      function cleanup(){
        transport.removeListener(&#x27;open&#x27;, onTransportOpen);
        transport.removeListener(&#x27;error&#x27;, onerror);
        transport.removeListener(&#x27;close&#x27;, onTransportClose);
        self.removeListener(&#x27;close&#x27;, onclose);
        self.removeListener(&#x27;upgrading&#x27;, onupgrade);
      }

      transport.once(&#x27;open&#x27;, onTransportOpen);
      transport.once(&#x27;error&#x27;, onerror);
      transport.once(&#x27;close&#x27;, onTransportClose);

      this.once(&#x27;close&#x27;, onclose);
      this.once(&#x27;upgrading&#x27;, onupgrade);

      transport.open();

    };

    /**
     * Called when connection is deemed open.
     *
     * @api public
     */

    Socket.prototype.onOpen = function () {
      debug(&#x27;socket open&#x27;);
      this.readyState = &#x27;open&#x27;;
      Socket.priorWebsocketSuccess = &#x27;websocket&#x27; == this.transport.name;
      this.emit(&#x27;open&#x27;);
      this.flush();

      // we check for &#x60;readyState&#x60; in case an &#x60;open&#x60;
      // listener already closed the socket
      if (&#x27;open&#x27; == this.readyState &amp;&amp; this.upgrade &amp;&amp; this.transport.pause) {
        debug(&#x27;starting upgrade probes&#x27;);
        for (var i = 0, l = this.upgrades.length; i &lt; l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    };

    /**
     * Handles a packet.
     *
     * @api private
     */

    Socket.prototype.onPacket = function (packet) {
      if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState) {
        debug(&#x27;socket receive: type &quot;%s&quot;, data &quot;%s&quot;&#x27;, packet.type, packet.data);

        this.emit(&#x27;packet&#x27;, packet);

        // Socket is live - any packet counts
        this.emit(&#x27;heartbeat&#x27;);

        switch (packet.type) {
          case &#x27;open&#x27;:
            this.onHandshake(parsejson(packet.data));
            break;

          case &#x27;pong&#x27;:
            this.setPing();
            this.emit(&#x27;pong&#x27;);
            break;

          case &#x27;error&#x27;:
            var err = new Error(&#x27;server error&#x27;);
            err.code = packet.data;
            this.onError(err);
            break;

          case &#x27;message&#x27;:
            this.emit(&#x27;data&#x27;, packet.data);
            this.emit(&#x27;message&#x27;, packet.data);
            break;
        }
      } else {
        debug(&#x27;packet received with socket readyState &quot;%s&quot;&#x27;, this.readyState);
      }
    };

    /**
     * Called upon handshake completion.
     *
     * @param {Object} handshake obj
     * @api private
     */

    Socket.prototype.onHandshake = function (data) {
      this.emit(&#x27;handshake&#x27;, data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      // In case open handler closes socket
      if  (&#x27;closed&#x27; == this.readyState) return;
      this.setPing();

      // Prolong liveness of socket on heartbeat
      this.removeListener(&#x27;heartbeat&#x27;, this.onHeartbeat);
      this.on(&#x27;heartbeat&#x27;, this.onHeartbeat);
    };

    /**
     * Resets ping timeout.
     *
     * @api private
     */

    Socket.prototype.onHeartbeat = function (timeout) {
      clearTimeout(this.pingTimeoutTimer);
      var self = this;
      self.pingTimeoutTimer = setTimeout(function () {
        if (&#x27;closed&#x27; == self.readyState) return;
        self.onClose(&#x27;ping timeout&#x27;);
      }, timeout || (self.pingInterval + self.pingTimeout));
    };

    /**
     * Pings server every &#x60;this.pingInterval&#x60; and expects response
     * within &#x60;this.pingTimeout&#x60; or closes connection.
     *
     * @api private
     */

    Socket.prototype.setPing = function () {
      var self = this;
      clearTimeout(self.pingIntervalTimer);
      self.pingIntervalTimer = setTimeout(function () {
        debug(&#x27;writing ping packet - expecting pong within %sms&#x27;, self.pingTimeout);
        self.ping();
        self.onHeartbeat(self.pingTimeout);
      }, self.pingInterval);
    };

    /**
     * Sends a ping packet.
     *
     * @api private
     */

    Socket.prototype.ping = function () {
      var self = this;
      this.sendPacket(&#x27;ping&#x27;, function(){
        self.emit(&#x27;ping&#x27;);
      });
    };

    /**
     * Called on &#x60;drain&#x60; event
     *
     * @api private
     */

    Socket.prototype.onDrain = function() {
      this.writeBuffer.splice(0, this.prevBufferLen);

      // setting prevBufferLen = 0 is very important
      // for example, when upgrading, upgrade packet is sent over,
      // and a nonzero prevBufferLen could cause problems on &#x60;drain&#x60;
      this.prevBufferLen = 0;

      if (0 === this.writeBuffer.length) {
        this.emit(&#x27;drain&#x27;);
      } else {
        this.flush();
      }
    };

    /**
     * Flush write buffers.
     *
     * @api private
     */

    Socket.prototype.flush = function () {
      if (&#x27;closed&#x27; != this.readyState &amp;&amp; this.transport.writable &amp;&amp;
        !this.upgrading &amp;&amp; this.writeBuffer.length) {
        debug(&#x27;flushing %d packets in socket&#x27;, this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        // keep track of current length of writeBuffer
        // splice writeBuffer and callbackBuffer on &#x60;drain&#x60;
        this.prevBufferLen = this.writeBuffer.length;
        this.emit(&#x27;flush&#x27;);
      }
    };

    /**
     * Sends a message.
     *
     * @param {String} message.
     * @param {Function} callback function.
     * @param {Object} options.
     * @return {Socket} for chaining.
     * @api public
     */

    Socket.prototype.write =
      Socket.prototype.send = function (msg, options, fn) {
        this.sendPacket(&#x27;message&#x27;, msg, options, fn);
        return this;
      };

    /**
     * Sends a packet.
     *
     * @param {String} packet type.
     * @param {String} data.
     * @param {Object} options.
     * @param {Function} callback function.
     * @api private
     */

    Socket.prototype.sendPacket = function (type, data, options, fn) {
      if(&#x27;function&#x27; == typeof data) {
        fn = data;
        data = undefined;
      }

      if (&#x27;function&#x27; == typeof options) {
        fn = options;
        options = null;
      }

      if (&#x27;closing&#x27; == this.readyState || &#x27;closed&#x27; == this.readyState) {
        return;
      }

      options = options || {};
      options.compress = false !== options.compress;

      var packet = {
        type: type,
        data: data,
        options: options
      };
      this.emit(&#x27;packetCreate&#x27;, packet);
      this.writeBuffer.push(packet);
      if (fn) this.once(&#x27;flush&#x27;, fn);
      this.flush();
    };

    /**
     * Closes the connection.
     *
     * @api private
     */

    Socket.prototype.close = function () {
      if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState) {
        this.readyState = &#x27;closing&#x27;;

        var self = this;

        if (this.writeBuffer.length) {
          this.once(&#x27;drain&#x27;, function() {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }

      function close() {
        self.onClose(&#x27;forced close&#x27;);
        debug(&#x27;socket closing - telling transport to close&#x27;);
        self.transport.close();
      }

      function cleanupAndClose() {
        self.removeListener(&#x27;upgrade&#x27;, cleanupAndClose);
        self.removeListener(&#x27;upgradeError&#x27;, cleanupAndClose);
        close();
      }

      function waitForUpgrade() {
        // wait for upgrade to finish since we can&#x27;t send packets while pausing a transport
        self.once(&#x27;upgrade&#x27;, cleanupAndClose);
        self.once(&#x27;upgradeError&#x27;, cleanupAndClose);
      }

      return this;
    };

    /**
     * Called upon transport error
     *
     * @api private
     */

    Socket.prototype.onError = function (err) {
      debug(&#x27;socket error %j&#x27;, err);
      Socket.priorWebsocketSuccess = false;
      this.emit(&#x27;error&#x27;, err);
      this.onClose(&#x27;transport error&#x27;, err);
    };

    /**
     * Called upon transport close.
     *
     * @api private
     */

    Socket.prototype.onClose = function (reason, desc) {
      if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState || &#x27;closing&#x27; == this.readyState) {
        debug(&#x27;socket close with reason: &quot;%s&quot;&#x27;, reason);
        var self = this;

        // clear timers
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);

        // stop event from firing again for transport
        this.transport.removeAllListeners(&#x27;close&#x27;);

        // ensure transport won&#x27;t stay open
        this.transport.close();

        // ignore further transport communication
        this.transport.removeAllListeners();

        // set ready state
        this.readyState = &#x27;closed&#x27;;

        // clear session id
        this.id = null;

        // emit close event
        this.emit(&#x27;close&#x27;, reason, desc);

        // clean buffers after, so users can still
        // grab the buffers on &#x60;close&#x60; event
        self.writeBuffer = [];
        self.prevBufferLen = 0;
      }
    };

    /**
     * Filters upgrades, returning only those matching client transports.
     *
     * @param {Array} server upgrades
     * @api private
     *
     */

    Socket.prototype.filterUpgrades = function (upgrades) {
      var filteredUpgrades = [];
      for (var i = 0, j = upgrades.length; i&lt;j; i++) {
        if (~index(this.transports, upgrades[i])) filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    };

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;./transport&quot;:4,&quot;./transports&quot;:5,&quot;component-emitter&quot;:15,&quot;debug&quot;:17,&quot;engine.io-parser&quot;:19,&quot;indexof&quot;:23,&quot;parsejson&quot;:26,&quot;parseqs&quot;:27,&quot;parseuri&quot;:28}],4:[function(_dereq_,module,exports){
  /**
   * Module dependencies.
   */

  var parser = _dereq_(&#x27;engine.io-parser&#x27;);
  var Emitter = _dereq_(&#x27;component-emitter&#x27;);

  /**
   * Module exports.
   */

  module.exports = Transport;

  /**
   * Transport abstract constructor.
   *
   * @param {Object} options.
   * @api private
   */

  function Transport (opts) {
    this.path = opts.path;
    this.hostname = opts.hostname;
    this.port = opts.port;
    this.secure = opts.secure;
    this.query = opts.query;
    this.timestampParam = opts.timestampParam;
    this.timestampRequests = opts.timestampRequests;
    this.readyState = &#x27;&#x27;;
    this.agent = opts.agent || false;
    this.socket = opts.socket;
    this.enablesXDR = opts.enablesXDR;

    // SSL options for Node.js client
    this.pfx = opts.pfx;
    this.key = opts.key;
    this.passphrase = opts.passphrase;
    this.cert = opts.cert;
    this.ca = opts.ca;
    this.ciphers = opts.ciphers;
    this.rejectUnauthorized = opts.rejectUnauthorized;

    // other options for Node.js client
    this.extraHeaders = opts.extraHeaders;
  }

  /**
   * Mix in &#x60;Emitter&#x60;.
   */

  Emitter(Transport.prototype);

  /**
   * Emits an error.
   *
   * @param {String} str
   * @return {Transport} for chaining
   * @api public
   */

  Transport.prototype.onError = function (msg, desc) {
    var err = new Error(msg);
    err.type = &#x27;TransportError&#x27;;
    err.description = desc;
    this.emit(&#x27;error&#x27;, err);
    return this;
  };

  /**
   * Opens the transport.
   *
   * @api public
   */

  Transport.prototype.open = function () {
    if (&#x27;closed&#x27; == this.readyState || &#x27;&#x27; == this.readyState) {
      this.readyState = &#x27;opening&#x27;;
      this.doOpen();
    }

    return this;
  };

  /**
   * Closes the transport.
   *
   * @api private
   */

  Transport.prototype.close = function () {
    if (&#x27;opening&#x27; == this.readyState || &#x27;open&#x27; == this.readyState) {
      this.doClose();
      this.onClose();
    }

    return this;
  };

  /**
   * Sends multiple packets.
   *
   * @param {Array} packets
   * @api private
   */

  Transport.prototype.send = function(packets){
    if (&#x27;open&#x27; == this.readyState) {
      this.write(packets);
    } else {
      throw new Error(&#x27;Transport not open&#x27;);
    }
  };

  /**
   * Called upon open
   *
   * @api private
   */

  Transport.prototype.onOpen = function () {
    this.readyState = &#x27;open&#x27;;
    this.writable = true;
    this.emit(&#x27;open&#x27;);
  };

  /**
   * Called with data.
   *
   * @param {String} data
   * @api private
   */

  Transport.prototype.onData = function(data){
    var packet = parser.decodePacket(data, this.socket.binaryType);
    this.onPacket(packet);
  };

  /**
   * Called with a decoded packet.
   */

  Transport.prototype.onPacket = function (packet) {
    this.emit(&#x27;packet&#x27;, packet);
  };

  /**
   * Called upon close.
   *
   * @api private
   */

  Transport.prototype.onClose = function () {
    this.readyState = &#x27;closed&#x27;;
    this.emit(&#x27;close&#x27;);
  };

},{&quot;component-emitter&quot;:15,&quot;engine.io-parser&quot;:19}],5:[function(_dereq_,module,exports){
  (function (global){
    /**
     * Module dependencies
     */

    var XMLHttpRequest = _dereq_(&#x27;xmlhttprequest-ssl&#x27;);
    var XHR = _dereq_(&#x27;./polling-xhr&#x27;);
    var JSONP = _dereq_(&#x27;./polling-jsonp&#x27;);
    var websocket = _dereq_(&#x27;./websocket&#x27;);

    /**
     * Export transports.
     */

    exports.polling = polling;
    exports.websocket = websocket;

    /**
     * Polling transport polymorphic constructor.
     * Decides on xhr vs jsonp based on feature detection.
     *
     * @api private
     */

    function polling(opts){
      var xhr;
      var xd = false;
      var xs = false;
      var jsonp = false !== opts.jsonp;

      if (global.location) {
        var isSSL = &#x27;https:&#x27; == location.protocol;
        var port = location.port;

        // some user agents have empty &#x60;location.port&#x60;
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        xd = opts.hostname != location.hostname || port != opts.port;
        xs = opts.secure != isSSL;
      }

      opts.xdomain = xd;
      opts.xscheme = xs;
      xhr = new XMLHttpRequest(opts);

      if (&#x27;open&#x27; in xhr &amp;&amp; !opts.forceJSONP) {
        return new XHR(opts);
      } else {
        if (!jsonp) throw new Error(&#x27;JSONP disabled&#x27;);
        return new JSONP(opts);
      }
    }

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;./polling-jsonp&quot;:6,&quot;./polling-xhr&quot;:7,&quot;./websocket&quot;:9,&quot;xmlhttprequest-ssl&quot;:10}],6:[function(_dereq_,module,exports){
  (function (global){

    /**
     * Module requirements.
     */

    var Polling = _dereq_(&#x27;./polling&#x27;);
    var inherit = _dereq_(&#x27;component-inherit&#x27;);

    /**
     * Module exports.
     */

    module.exports = JSONPPolling;

    /**
     * Cached regular expressions.
     */

    var rNewline = /\n/g;
    var rEscapedNewline = /\\n/g;

    /**
     * Global JSONP callbacks.
     */

    var callbacks;

    /**
     * Callbacks count.
     */

    var index = 0;

    /**
     * Noop.
     */

    function empty () { }

    /**
     * JSONP Polling constructor.
     *
     * @param {Object} opts.
     * @api public
     */

    function JSONPPolling (opts) {
      Polling.call(this, opts);

      this.query = this.query || {};

      // define global callbacks array if not present
      // we do this here (lazily) to avoid unneeded global pollution
      if (!callbacks) {
        // we need to consider multiple engines in the same page
        if (!global.___eio) global.___eio = [];
        callbacks = global.___eio;
      }

      // callback identifier
      this.index = callbacks.length;

      // add callback to jsonp global
      var self = this;
      callbacks.push(function (msg) {
        self.onData(msg);
      });

      // append to query string
      this.query.j = this.index;

      // prevent spurious errors from being emitted when the window is unloaded
      if (global.document &amp;&amp; global.addEventListener) {
        global.addEventListener(&#x27;beforeunload&#x27;, function () {
          if (self.script) self.script.onerror = empty;
        }, false);
      }
    }

    /**
     * Inherits from Polling.
     */

    inherit(JSONPPolling, Polling);

    /*
     * JSONP only supports binary as base64 encoded strings
     */

    JSONPPolling.prototype.supportsBinary = false;

    /**
     * Closes the socket.
     *
     * @api private
     */

    JSONPPolling.prototype.doClose = function () {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }

      Polling.prototype.doClose.call(this);
    };

    /**
     * Starts a poll cycle.
     *
     * @api private
     */

    JSONPPolling.prototype.doPoll = function () {
      var self = this;
      var script = document.createElement(&#x27;script&#x27;);

      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }

      script.async = true;
      script.src = this.uri();
      script.onerror = function(e){
        self.onError(&#x27;jsonp poll error&#x27;,e);
      };

      var insertAt = document.getElementsByTagName(&#x27;script&#x27;)[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      }
      else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;

      var isUAgecko = &#x27;undefined&#x27; != typeof navigator &amp;&amp; /gecko/i.test(navigator.userAgent);

      if (isUAgecko) {
        setTimeout(function () {
          var iframe = document.createElement(&#x27;iframe&#x27;);
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    };

    /**
     * Writes with a hidden iframe.
     *
     * @param {String} data to send
     * @param {Function} called upon flush.
     * @api private
     */

    JSONPPolling.prototype.doWrite = function (data, fn) {
      var self = this;

      if (!this.form) {
        var form = document.createElement(&#x27;form&#x27;);
        var area = document.createElement(&#x27;textarea&#x27;);
        var id = this.iframeId = &#x27;eio_iframe_&#x27; + this.index;
        var iframe;

        form.className = &#x27;socketio&#x27;;
        form.style.position = &#x27;absolute&#x27;;
        form.style.top = &#x27;-1000px&#x27;;
        form.style.left = &#x27;-1000px&#x27;;
        form.target = id;
        form.method = &#x27;POST&#x27;;
        form.setAttribute(&#x27;accept-charset&#x27;, &#x27;utf-8&#x27;);
        area.name = &#x27;d&#x27;;
        form.appendChild(area);
        document.body.appendChild(form);

        this.form = form;
        this.area = area;
      }

      this.form.action = this.uri();

      function complete () {
        initIframe();
        fn();
      }

      function initIframe () {
        if (self.iframe) {
          try {
            self.form.removeChild(self.iframe);
          } catch (e) {
            self.onError(&#x27;jsonp polling iframe removal error&#x27;, e);
          }
        }

        try {
          // ie6 dynamic iframes with target=&quot;&quot; support (thanks Chris Lambacher)
          var html = &#x27;&lt;iframe src=&quot;javascript:0&quot; name=&quot;&#x27;+ self.iframeId +&#x27;&quot;&gt;&#x27;;
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement(&#x27;iframe&#x27;);
          iframe.name = self.iframeId;
          iframe.src = &#x27;javascript:0&#x27;;
        }

        iframe.id = self.iframeId;

        self.form.appendChild(iframe);
        self.iframe = iframe;
      }

      initIframe();

      // escape \n to prevent it from being converted into \r\n by some UAs
      // double escaping is required for escaped new lines because unescaping of new lines can be done safely on server-side
      data = data.replace(rEscapedNewline, &#x27;\\\n&#x27;);
      this.area.value = data.replace(rNewline, &#x27;\\n&#x27;);

      try {
        this.form.submit();
      } catch(e) {}

      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function(){
          if (self.iframe.readyState == &#x27;complete&#x27;) {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    };

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;./polling&quot;:8,&quot;component-inherit&quot;:16}],7:[function(_dereq_,module,exports){
  (function (global){
    /**
     * Module requirements.
     */

    var XMLHttpRequest = _dereq_(&#x27;xmlhttprequest-ssl&#x27;);
    var Polling = _dereq_(&#x27;./polling&#x27;);
    var Emitter = _dereq_(&#x27;component-emitter&#x27;);
    var inherit = _dereq_(&#x27;component-inherit&#x27;);
    var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:polling-xhr&#x27;);

    /**
     * Module exports.
     */

    module.exports = XHR;
    module.exports.Request = Request;

    /**
     * Empty function
     */

    function empty(){}

    /**
     * XHR Polling constructor.
     *
     * @param {Object} opts
     * @api public
     */

    function XHR(opts){
      Polling.call(this, opts);

      if (global.location) {
        var isSSL = &#x27;https:&#x27; == location.protocol;
        var port = location.port;

        // some user agents have empty &#x60;location.port&#x60;
        if (!port) {
          port = isSSL ? 443 : 80;
        }

        this.xd = opts.hostname != global.location.hostname ||
          port != opts.port;
        this.xs = opts.secure != isSSL;
      } else {
        this.extraHeaders = opts.extraHeaders;
      }
    }

    /**
     * Inherits from Polling.
     */

    inherit(XHR, Polling);

    /**
     * XHR supports binary
     */

    XHR.prototype.supportsBinary = true;

    /**
     * Creates a request.
     *
     * @param {String} method
     * @api private
     */

    XHR.prototype.request = function(opts){
      opts = opts || {};
      opts.uri = this.uri();
      opts.xd = this.xd;
      opts.xs = this.xs;
      opts.agent = this.agent || false;
      opts.supportsBinary = this.supportsBinary;
      opts.enablesXDR = this.enablesXDR;

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;

      // other options for Node.js client
      opts.extraHeaders = this.extraHeaders;

      return new Request(opts);
    };

    /**
     * Sends data.
     *
     * @param {String} data to send.
     * @param {Function} called upon flush.
     * @api private
     */

    XHR.prototype.doWrite = function(data, fn){
      var isBinary = typeof data !== &#x27;string&#x27; &amp;&amp; data !== undefined;
      var req = this.request({ method: &#x27;POST&#x27;, data: data, isBinary: isBinary });
      var self = this;
      req.on(&#x27;success&#x27;, fn);
      req.on(&#x27;error&#x27;, function(err){
        self.onError(&#x27;xhr post error&#x27;, err);
      });
      this.sendXhr = req;
    };

    /**
     * Starts a poll cycle.
     *
     * @api private
     */

    XHR.prototype.doPoll = function(){
      debug(&#x27;xhr poll&#x27;);
      var req = this.request();
      var self = this;
      req.on(&#x27;data&#x27;, function(data){
        self.onData(data);
      });
      req.on(&#x27;error&#x27;, function(err){
        self.onError(&#x27;xhr poll error&#x27;, err);
      });
      this.pollXhr = req;
    };

    /**
     * Request constructor
     *
     * @param {Object} options
     * @api public
     */

    function Request(opts){
      this.method = opts.method || &#x27;GET&#x27;;
      this.uri = opts.uri;
      this.xd = !!opts.xd;
      this.xs = !!opts.xs;
      this.async = false !== opts.async;
      this.data = undefined != opts.data ? opts.data : null;
      this.agent = opts.agent;
      this.isBinary = opts.isBinary;
      this.supportsBinary = opts.supportsBinary;
      this.enablesXDR = opts.enablesXDR;

      // SSL options for Node.js client
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;

      // other options for Node.js client
      this.extraHeaders = opts.extraHeaders;

      this.create();
    }

    /**
     * Mix in &#x60;Emitter&#x60;.
     */

    Emitter(Request.prototype);

    /**
     * Creates the XHR object and sends the request.
     *
     * @api private
     */

    Request.prototype.create = function(){
      var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;

      var xhr = this.xhr = new XMLHttpRequest(opts);
      var self = this;

      try {
        debug(&#x27;xhr open %s: %s&#x27;, this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.extraHeaders) {
            xhr.setDisableHeaderCheck(true);
            for (var i in this.extraHeaders) {
              if (this.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.extraHeaders[i]);
              }
            }
          }
        } catch (e) {}
        if (this.supportsBinary) {
          // This has to be done after open because Firefox is stupid
          // http://stackoverflow.com/questions/13216903/get-binary-data-with-xmlhttprequest-in-a-firefox-extension
          xhr.responseType = &#x27;arraybuffer&#x27;;
        }

        if (&#x27;POST&#x27; == this.method) {
          try {
            if (this.isBinary) {
              xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;application/octet-stream&#x27;);
            } else {
              xhr.setRequestHeader(&#x27;Content-type&#x27;, &#x27;text/plain;charset=UTF-8&#x27;);
            }
          } catch (e) {}
        }

        // ie6 check
        if (&#x27;withCredentials&#x27; in xhr) {
          xhr.withCredentials = true;
        }

        if (this.hasXDR()) {
          xhr.onload = function(){
            self.onLoad();
          };
          xhr.onerror = function(){
            self.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function(){
            if (4 != xhr.readyState) return;
            if (200 == xhr.status || 1223 == xhr.status) {
              self.onLoad();
            } else {
              // make sure the &#x60;error&#x60; event handler that&#x27;s user-set
              // does not throw in the same tick and gets caught here
              setTimeout(function(){
                self.onError(xhr.status);
              }, 0);
            }
          };
        }

        debug(&#x27;xhr data %s&#x27;, this.data);
        xhr.send(this.data);
      } catch (e) {
        // Need to defer since .create() is called directly fhrom the constructor
        // and thus the &#x27;error&#x27; event can only be only bound *after* this exception
        // occurs.  Therefore, also, we cannot throw here at all.
        setTimeout(function() {
          self.onError(e);
        }, 0);
        return;
      }

      if (global.document) {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    };

    /**
     * Called upon successful response.
     *
     * @api private
     */

    Request.prototype.onSuccess = function(){
      this.emit(&#x27;success&#x27;);
      this.cleanup();
    };

    /**
     * Called if we have data.
     *
     * @api private
     */

    Request.prototype.onData = function(data){
      this.emit(&#x27;data&#x27;, data);
      this.onSuccess();
    };

    /**
     * Called upon error.
     *
     * @api private
     */

    Request.prototype.onError = function(err){
      this.emit(&#x27;error&#x27;, err);
      this.cleanup(true);
    };

    /**
     * Cleans up house.
     *
     * @api private
     */

    Request.prototype.cleanup = function(fromError){
      if (&#x27;undefined&#x27; == typeof this.xhr || null === this.xhr) {
        return;
      }
      // xmlhttprequest
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty;
      } else {
        this.xhr.onreadystatechange = empty;
      }

      if (fromError) {
        try {
          this.xhr.abort();
        } catch(e) {}
      }

      if (global.document) {
        delete Request.requests[this.index];
      }

      this.xhr = null;
    };

    /**
     * Called upon load.
     *
     * @api private
     */

    Request.prototype.onLoad = function(){
      var data;
      try {
        var contentType;
        try {
          contentType = this.xhr.getResponseHeader(&#x27;Content-Type&#x27;).split(&#x27;;&#x27;)[0];
        } catch (e) {}
        if (contentType === &#x27;application/octet-stream&#x27;) {
          data = this.xhr.response;
        } else {
          if (!this.supportsBinary) {
            data = this.xhr.responseText;
          } else {
            try {
              data = String.fromCharCode.apply(null, new Uint8Array(this.xhr.response));
            } catch (e) {
              var ui8Arr = new Uint8Array(this.xhr.response);
              var dataArray = [];
              for (var idx = 0, length = ui8Arr.length; idx &lt; length; idx++) {
                dataArray.push(ui8Arr[idx]);
              }

              data = String.fromCharCode.apply(null, dataArray);
            }
          }
        }
      } catch (e) {
        this.onError(e);
      }
      if (null != data) {
        this.onData(data);
      }
    };

    /**
     * Check if it has XDomainRequest.
     *
     * @api private
     */

    Request.prototype.hasXDR = function(){
      return &#x27;undefined&#x27; !== typeof global.XDomainRequest &amp;&amp; !this.xs &amp;&amp; this.enablesXDR;
    };

    /**
     * Aborts the request.
     *
     * @api public
     */

    Request.prototype.abort = function(){
      this.cleanup();
    };

    /**
     * Aborts pending requests when unloading the window. This is needed to prevent
     * memory leaks (e.g. when using IE) and to ensure that no spurious error is
     * emitted.
     */

    if (global.document) {
      Request.requestsCount = 0;
      Request.requests = {};
      if (global.attachEvent) {
        global.attachEvent(&#x27;onunload&#x27;, unloadHandler);
      } else if (global.addEventListener) {
        global.addEventListener(&#x27;beforeunload&#x27;, unloadHandler, false);
      }
    }

    function unloadHandler() {
      for (var i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;./polling&quot;:8,&quot;component-emitter&quot;:15,&quot;component-inherit&quot;:16,&quot;debug&quot;:17,&quot;xmlhttprequest-ssl&quot;:10}],8:[function(_dereq_,module,exports){
  /**
   * Module dependencies.
   */

  var Transport = _dereq_(&#x27;../transport&#x27;);
  var parseqs = _dereq_(&#x27;parseqs&#x27;);
  var parser = _dereq_(&#x27;engine.io-parser&#x27;);
  var inherit = _dereq_(&#x27;component-inherit&#x27;);
  var yeast = _dereq_(&#x27;yeast&#x27;);
  var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:polling&#x27;);

  /**
   * Module exports.
   */

  module.exports = Polling;

  /**
   * Is XHR2 supported?
   */

  var hasXHR2 = (function() {
    var XMLHttpRequest = _dereq_(&#x27;xmlhttprequest-ssl&#x27;);
    var xhr = new XMLHttpRequest({ xdomain: false });
    return null != xhr.responseType;
  })();

  /**
   * Polling interface.
   *
   * @param {Object} opts
   * @api private
   */

  function Polling(opts){
    var forceBase64 = (opts &amp;&amp; opts.forceBase64);
    if (!hasXHR2 || forceBase64) {
      this.supportsBinary = false;
    }
    Transport.call(this, opts);
  }

  /**
   * Inherits from Transport.
   */

  inherit(Polling, Transport);

  /**
   * Transport name.
   */

  Polling.prototype.name = &#x27;polling&#x27;;

  /**
   * Opens the socket (triggers polling). We write a PING message to determine
   * when the transport is open.
   *
   * @api private
   */

  Polling.prototype.doOpen = function(){
    this.poll();
  };

  /**
   * Pauses polling.
   *
   * @param {Function} callback upon buffers are flushed and transport is paused
   * @api private
   */

  Polling.prototype.pause = function(onPause){
    var pending = 0;
    var self = this;

    this.readyState = &#x27;pausing&#x27;;

    function pause(){
      debug(&#x27;paused&#x27;);
      self.readyState = &#x27;paused&#x27;;
      onPause();
    }

    if (this.polling || !this.writable) {
      var total = 0;

      if (this.polling) {
        debug(&#x27;we are currently polling - waiting to pause&#x27;);
        total++;
        this.once(&#x27;pollComplete&#x27;, function(){
          debug(&#x27;pre-pause polling complete&#x27;);
          --total || pause();
        });
      }

      if (!this.writable) {
        debug(&#x27;we are currently writing - waiting to pause&#x27;);
        total++;
        this.once(&#x27;drain&#x27;, function(){
          debug(&#x27;pre-pause writing complete&#x27;);
          --total || pause();
        });
      }
    } else {
      pause();
    }
  };

  /**
   * Starts polling cycle.
   *
   * @api public
   */

  Polling.prototype.poll = function(){
    debug(&#x27;polling&#x27;);
    this.polling = true;
    this.doPoll();
    this.emit(&#x27;poll&#x27;);
  };

  /**
   * Overloads onData to detect payloads.
   *
   * @api private
   */

  Polling.prototype.onData = function(data){
    var self = this;
    debug(&#x27;polling got data %s&#x27;, data);
    var callback = function(packet, index, total) {
      // if its the first message we consider the transport open
      if (&#x27;opening&#x27; == self.readyState) {
        self.onOpen();
      }

      // if its a close packet, we close the ongoing requests
      if (&#x27;close&#x27; == packet.type) {
        self.onClose();
        return false;
      }

      // otherwise bypass onData and handle the message
      self.onPacket(packet);
    };

    // decode payload
    parser.decodePayload(data, this.socket.binaryType, callback);

    // if an event did not trigger closing
    if (&#x27;closed&#x27; != this.readyState) {
      // if we got data we&#x27;re not polling
      this.polling = false;
      this.emit(&#x27;pollComplete&#x27;);

      if (&#x27;open&#x27; == this.readyState) {
        this.poll();
      } else {
        debug(&#x27;ignoring poll - transport state &quot;%s&quot;&#x27;, this.readyState);
      }
    }
  };

  /**
   * For polling, send a close packet.
   *
   * @api private
   */

  Polling.prototype.doClose = function(){
    var self = this;

    function close(){
      debug(&#x27;writing close packet&#x27;);
      self.write([{ type: &#x27;close&#x27; }]);
    }

    if (&#x27;open&#x27; == this.readyState) {
      debug(&#x27;transport open - closing&#x27;);
      close();
    } else {
      // in case we&#x27;re trying to close while
      // handshaking is in progress (GH-164)
      debug(&#x27;transport not open - deferring close&#x27;);
      this.once(&#x27;open&#x27;, close);
    }
  };

  /**
   * Writes a packets payload.
   *
   * @param {Array} data packets
   * @param {Function} drain callback
   * @api private
   */

  Polling.prototype.write = function(packets){
    var self = this;
    this.writable = false;
    var callbackfn = function() {
      self.writable = true;
      self.emit(&#x27;drain&#x27;);
    };

    var self = this;
    parser.encodePayload(packets, this.supportsBinary, function(data) {
      self.doWrite(data, callbackfn);
    });
  };

  /**
   * Generates uri for connection.
   *
   * @api private
   */

  Polling.prototype.uri = function(){
    var query = this.query || {};
    var schema = this.secure ? &#x27;https&#x27; : &#x27;http&#x27;;
    var port = &#x27;&#x27;;

    // cache busting is forced
    if (false !== this.timestampRequests) {
      query[this.timestampParam] = yeast();
    }

    if (!this.supportsBinary &amp;&amp; !query.sid) {
      query.b64 = 1;
    }

    query = parseqs.encode(query);

    // avoid port if default for schema
    if (this.port &amp;&amp; ((&#x27;https&#x27; == schema &amp;&amp; this.port != 443) ||
      (&#x27;http&#x27; == schema &amp;&amp; this.port != 80))) {
      port = &#x27;:&#x27; + this.port;
    }

    // prepend ? to query
    if (query.length) {
      query = &#x27;?&#x27; + query;
    }

    var ipv6 = this.hostname.indexOf(&#x27;:&#x27;) !== -1;
    return schema + &#x27;://&#x27; + (ipv6 ? &#x27;[&#x27; + this.hostname + &#x27;]&#x27; : this.hostname) + port + this.path + query;
  };

},{&quot;../transport&quot;:4,&quot;component-inherit&quot;:16,&quot;debug&quot;:17,&quot;engine.io-parser&quot;:19,&quot;parseqs&quot;:27,&quot;xmlhttprequest-ssl&quot;:10,&quot;yeast&quot;:30}],9:[function(_dereq_,module,exports){
  (function (global){
    /**
     * Module dependencies.
     */

    var Transport = _dereq_(&#x27;../transport&#x27;);
    var parser = _dereq_(&#x27;engine.io-parser&#x27;);
    var parseqs = _dereq_(&#x27;parseqs&#x27;);
    var inherit = _dereq_(&#x27;component-inherit&#x27;);
    var yeast = _dereq_(&#x27;yeast&#x27;);
    var debug = _dereq_(&#x27;debug&#x27;)(&#x27;engine.io-client:websocket&#x27;);
    var BrowserWebSocket = global.WebSocket || global.MozWebSocket;

    /**
     * Get either the &#x60;WebSocket&#x60; or &#x60;MozWebSocket&#x60; globals
     * in the browser or try to resolve WebSocket-compatible
     * interface exposed by &#x60;ws&#x60; for Node-like environment.
     */

    var WebSocket = BrowserWebSocket;
    if (!WebSocket &amp;&amp; typeof window === &#x27;undefined&#x27;) {
      try {
        WebSocket = _dereq_(&#x27;ws&#x27;);
      } catch (e) { }
    }

    /**
     * Module exports.
     */

    module.exports = WS;

    /**
     * WebSocket transport constructor.
     *
     * @api {Object} connection options
     * @api public
     */

    function WS(opts){
      var forceBase64 = (opts &amp;&amp; opts.forceBase64);
      if (forceBase64) {
        this.supportsBinary = false;
      }
      this.perMessageDeflate = opts.perMessageDeflate;
      Transport.call(this, opts);
    }

    /**
     * Inherits from Transport.
     */

    inherit(WS, Transport);

    /**
     * Transport name.
     *
     * @api public
     */

    WS.prototype.name = &#x27;websocket&#x27;;

    /*
     * WebSockets support binary
     */

    WS.prototype.supportsBinary = true;

    /**
     * Opens socket.
     *
     * @api private
     */

    WS.prototype.doOpen = function(){
      if (!this.check()) {
        // let probe timeout
        return;
      }

      var self = this;
      var uri = this.uri();
      var protocols = void(0);
      var opts = {
        agent: this.agent,
        perMessageDeflate: this.perMessageDeflate
      };

      // SSL options for Node.js client
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      if (this.extraHeaders) {
        opts.headers = this.extraHeaders;
      }

      this.ws = BrowserWebSocket ? new WebSocket(uri) : new WebSocket(uri, protocols, opts);

      if (this.ws.binaryType === undefined) {
        this.supportsBinary = false;
      }

      if (this.ws.supports &amp;&amp; this.ws.supports.binary) {
        this.supportsBinary = true;
        this.ws.binaryType = &#x27;buffer&#x27;;
      } else {
        this.ws.binaryType = &#x27;arraybuffer&#x27;;
      }

      this.addEventListeners();
    };

    /**
     * Adds event listeners to the socket
     *
     * @api private
     */

    WS.prototype.addEventListeners = function(){
      var self = this;

      this.ws.onopen = function(){
        self.onOpen();
      };
      this.ws.onclose = function(){
        self.onClose();
      };
      this.ws.onmessage = function(ev){
        self.onData(ev.data);
      };
      this.ws.onerror = function(e){
        self.onError(&#x27;websocket error&#x27;, e);
      };
    };

    /**
     * Override &#x60;onData&#x60; to use a timer on iOS.
     * See: https://gist.github.com/mloughran/2052006
     *
     * @api private
     */

    if (&#x27;undefined&#x27; != typeof navigator
      &amp;&amp; /iPad|iPhone|iPod/i.test(navigator.userAgent)) {
      WS.prototype.onData = function(data){
        var self = this;
        setTimeout(function(){
          Transport.prototype.onData.call(self, data);
        }, 0);
      };
    }

    /**
     * Writes data to socket.
     *
     * @param {Array} array of packets.
     * @api private
     */

    WS.prototype.write = function(packets){
      var self = this;
      this.writable = false;

      // encodePacket efficient as it uses WS framing
      // no need for encodePayload
      var total = packets.length;
      for (var i = 0, l = total; i &lt; l; i++) {
        (function(packet) {
          parser.encodePacket(packet, self.supportsBinary, function(data) {
            if (!BrowserWebSocket) {
              // always create a new object (GH-437)
              var opts = {};
              if (packet.options) {
                opts.compress = packet.options.compress;
              }

              if (self.perMessageDeflate) {
                var len = &#x27;string&#x27; == typeof data ? global.Buffer.byteLength(data) : data.length;
                if (len &lt; self.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }

            //Sometimes the websocket has already been closed but the browser didn&#x27;t
            //have a chance of informing us about it yet, in that case send will
            //throw an error
            try {
              if (BrowserWebSocket) {
                // TypeError is thrown when passing the second argument on Safari
                self.ws.send(data);
              } else {
                self.ws.send(data, opts);
              }
            } catch (e){
              debug(&#x27;websocket closed before onclose event&#x27;);
            }

            --total || done();
          });
        })(packets[i]);
      }

      function done(){
        self.emit(&#x27;flush&#x27;);

        // fake drain
        // defer to next tick to allow Socket to clear writeBuffer
        setTimeout(function(){
          self.writable = true;
          self.emit(&#x27;drain&#x27;);
        }, 0);
      }
    };

    /**
     * Called upon close
     *
     * @api private
     */

    WS.prototype.onClose = function(){
      Transport.prototype.onClose.call(this);
    };

    /**
     * Closes socket.
     *
     * @api private
     */

    WS.prototype.doClose = function(){
      if (typeof this.ws !== &#x27;undefined&#x27;) {
        this.ws.close();
      }
    };

    /**
     * Generates uri for connection.
     *
     * @api private
     */

    WS.prototype.uri = function(){
      var query = this.query || {};
      var schema = this.secure ? &#x27;wss&#x27; : &#x27;ws&#x27;;
      var port = &#x27;&#x27;;

      // avoid port if default for schema
      if (this.port &amp;&amp; ((&#x27;wss&#x27; == schema &amp;&amp; this.port != 443)
        || (&#x27;ws&#x27; == schema &amp;&amp; this.port != 80))) {
        port = &#x27;:&#x27; + this.port;
      }

      // append timestamp to URI
      if (this.timestampRequests) {
        query[this.timestampParam] = yeast();
      }

      // communicate binary support capabilities
      if (!this.supportsBinary) {
        query.b64 = 1;
      }

      query = parseqs.encode(query);

      // prepend ? to query
      if (query.length) {
        query = &#x27;?&#x27; + query;
      }

      var ipv6 = this.hostname.indexOf(&#x27;:&#x27;) !== -1;
      return schema + &#x27;://&#x27; + (ipv6 ? &#x27;[&#x27; + this.hostname + &#x27;]&#x27; : this.hostname) + port + this.path + query;
    };

    /**
     * Feature detection for WebSocket.
     *
     * @return {Boolean} whether this transport is available.
     * @api public
     */

    WS.prototype.check = function(){
      return !!WebSocket &amp;&amp; !(&#x27;__initialize&#x27; in WebSocket &amp;&amp; this.name === WS.prototype.name);
    };

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;../transport&quot;:4,&quot;component-inherit&quot;:16,&quot;debug&quot;:17,&quot;engine.io-parser&quot;:19,&quot;parseqs&quot;:27,&quot;ws&quot;:undefined,&quot;yeast&quot;:30}],10:[function(_dereq_,module,exports){
// browser shim for xmlhttprequest module
  var hasCORS = _dereq_(&#x27;has-cors&#x27;);

  module.exports = function(opts) {
    var xdomain = opts.xdomain;

    // scheme must be same when usign XDomainRequest
    // http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx
    var xscheme = opts.xscheme;

    // XDomainRequest has a flow of not sending cookie, therefore it should be disabled as a default.
    // https://github.com/Automattic/engine.io-client/pull/217
    var enablesXDR = opts.enablesXDR;

    // XMLHttpRequest can be disabled on IE
    try {
      if (&#x27;undefined&#x27; != typeof XMLHttpRequest &amp;&amp; (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) { }

    // Use XDomainRequest for IE8 if enablesXDR is true
    // because loading bar keeps flashing when using jsonp-polling
    // https://github.com/yujiosaka/socke.io-ie8-loading-example
    try {
      if (&#x27;undefined&#x27; != typeof XDomainRequest &amp;&amp; !xscheme &amp;&amp; enablesXDR) {
        return new XDomainRequest();
      }
    } catch (e) { }

    if (!xdomain) {
      try {
        return new ActiveXObject(&#x27;Microsoft.XMLHTTP&#x27;);
      } catch(e) { }
    }
  }

},{&quot;has-cors&quot;:22}],11:[function(_dereq_,module,exports){
  module.exports = after

  function after(count, callback, err_cb) {
    var bail = false
    err_cb = err_cb || noop
    proxy.count = count

    return (count === 0) ? callback() : proxy

    function proxy(err, result) {
      if (proxy.count &lt;= 0) {
        throw new Error(&#x27;after called too many times&#x27;)
      }
      --proxy.count

      // after first error, rest are passed to err_cb
      if (err) {
        bail = true
        callback(err)
        // future error callbacks will go to error handler
        callback = err_cb
      } else if (proxy.count === 0 &amp;&amp; !bail) {
        callback(null, result)
      }
    }
  }

  function noop() {}

},{}],12:[function(_dereq_,module,exports){
  /**
   * An abstraction for slicing an arraybuffer even when
   * ArrayBuffer.prototype.slice is not supported
   *
   * @api public
   */

  module.exports = function(arraybuffer, start, end) {
    var bytes = arraybuffer.byteLength;
    start = start || 0;
    end = end || bytes;

    if (arraybuffer.slice) { return arraybuffer.slice(start, end); }

    if (start &lt; 0) { start += bytes; }
    if (end &lt; 0) { end += bytes; }
    if (end &gt; bytes) { end = bytes; }

    if (start &gt;= bytes || start &gt;= end || bytes === 0) {
      return new ArrayBuffer(0);
    }

    var abv = new Uint8Array(arraybuffer);
    var result = new Uint8Array(end - start);
    for (var i = start, ii = 0; i &lt; end; i++, ii++) {
      result[ii] = abv[i];
    }
    return result.buffer;
  };

},{}],13:[function(_dereq_,module,exports){
  /*
   * base64-arraybuffer
   * https://github.com/niklasvh/base64-arraybuffer
   *
   * Copyright (c) 2012 Niklas von Hertzen
   * Licensed under the MIT license.
   */
  (function(chars){
    &quot;use strict&quot;;

    exports.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer),
        i, len = bytes.length, base64 = &quot;&quot;;

      for (i = 0; i &lt; len; i+=3) {
        base64 += chars[bytes[i] &gt;&gt; 2];
        base64 += chars[((bytes[i] &amp; 3) &lt;&lt; 4) | (bytes[i + 1] &gt;&gt; 4)];
        base64 += chars[((bytes[i + 1] &amp; 15) &lt;&lt; 2) | (bytes[i + 2] &gt;&gt; 6)];
        base64 += chars[bytes[i + 2] &amp; 63];
      }

      if ((len % 3) === 2) {
        base64 = base64.substring(0, base64.length - 1) + &quot;=&quot;;
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + &quot;==&quot;;
      }

      return base64;
    };

    exports.decode =  function(base64) {
      var bufferLength = base64.length * 0.75,
        len = base64.length, i, p = 0,
        encoded1, encoded2, encoded3, encoded4;

      if (base64[base64.length - 1] === &quot;=&quot;) {
        bufferLength--;
        if (base64[base64.length - 2] === &quot;=&quot;) {
          bufferLength--;
        }
      }

      var arraybuffer = new ArrayBuffer(bufferLength),
        bytes = new Uint8Array(arraybuffer);

      for (i = 0; i &lt; len; i+=4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i+1]);
        encoded3 = chars.indexOf(base64[i+2]);
        encoded4 = chars.indexOf(base64[i+3]);

        bytes[p++] = (encoded1 &lt;&lt; 2) | (encoded2 &gt;&gt; 4);
        bytes[p++] = ((encoded2 &amp; 15) &lt;&lt; 4) | (encoded3 &gt;&gt; 2);
        bytes[p++] = ((encoded3 &amp; 3) &lt;&lt; 6) | (encoded4 &amp; 63);
      }

      return arraybuffer;
    };
  })(&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;);

},{}],14:[function(_dereq_,module,exports){
  (function (global){
    /**
     * Create a blob builder even when vendor prefixes exist
     */

    var BlobBuilder = global.BlobBuilder
      || global.WebKitBlobBuilder
      || global.MSBlobBuilder
      || global.MozBlobBuilder;

    /**
     * Check if Blob constructor is supported
     */

    var blobSupported = (function() {
      try {
        var a = new Blob([&#x27;hi&#x27;]);
        return a.size === 2;
      } catch(e) {
        return false;
      }
    })();

    /**
     * Check if Blob constructor supports ArrayBufferViews
     * Fails in Safari 6, so we need to map to ArrayBuffers there.
     */

    var blobSupportsArrayBufferView = blobSupported &amp;&amp; (function() {
        try {
          var b = new Blob([new Uint8Array([1,2])]);
          return b.size === 2;
        } catch(e) {
          return false;
        }
      })();

    /**
     * Check if BlobBuilder is supported
     */

    var blobBuilderSupported = BlobBuilder
      &amp;&amp; BlobBuilder.prototype.append
      &amp;&amp; BlobBuilder.prototype.getBlob;

    /**
     * Helper function that maps ArrayBufferViews to ArrayBuffers
     * Used by BlobBuilder constructor and old browsers that didn&#x27;t
     * support it in the Blob constructor.
     */

    function mapArrayBufferViews(ary) {
      for (var i = 0; i &lt; ary.length; i++) {
        var chunk = ary[i];
        if (chunk.buffer instanceof ArrayBuffer) {
          var buf = chunk.buffer;

          // if this is a subarray, make a copy so we only
          // include the subarray region from the underlying buffer
          if (chunk.byteLength !== buf.byteLength) {
            var copy = new Uint8Array(chunk.byteLength);
            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
            buf = copy.buffer;
          }

          ary[i] = buf;
        }
      }
    }

    function BlobBuilderConstructor(ary, options) {
      options = options || {};

      var bb = new BlobBuilder();
      mapArrayBufferViews(ary);

      for (var i = 0; i &lt; ary.length; i++) {
        bb.append(ary[i]);
      }

      return (options.type) ? bb.getBlob(options.type) : bb.getBlob();
    };

    function BlobConstructor(ary, options) {
      mapArrayBufferViews(ary);
      return new Blob(ary, options || {});
    };

    module.exports = (function() {
      if (blobSupported) {
        return blobSupportsArrayBufferView ? global.Blob : BlobConstructor;
      } else if (blobBuilderSupported) {
        return BlobBuilderConstructor;
      } else {
        return undefined;
      }
    })();

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{}],15:[function(_dereq_,module,exports){

  /**
   * Expose &#x60;Emitter&#x60;.
   */

  module.exports = Emitter;

  /**
   * Initialize a new &#x60;Emitter&#x60;.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  };

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given &#x60;event&#x60; with &#x60;fn&#x60;.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks[event] = this._callbacks[event] || [])
        .push(fn);
      return this;
    };

  /**
   * Adds an &#x60;event&#x60; listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    var self = this;
    this._callbacks = this._callbacks || {};

    function on() {
      self.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for &#x60;event&#x60; or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
    Emitter.prototype.removeListener =
      Emitter.prototype.removeAllListeners =
        Emitter.prototype.removeEventListener = function(event, fn){
          this._callbacks = this._callbacks || {};

          // all
          if (0 == arguments.length) {
            this._callbacks = {};
            return this;
          }

          // specific event
          var callbacks = this._callbacks[event];
          if (!callbacks) return this;

          // remove all handlers
          if (1 == arguments.length) {
            delete this._callbacks[event];
            return this;
          }

          // remove specific handler
          var cb;
          for (var i = 0; i &lt; callbacks.length; i++) {
            cb = callbacks[i];
            if (cb === fn || cb.fn === fn) {
              callbacks.splice(i, 1);
              break;
            }
          }
          return this;
        };

  /**
   * Emit &#x60;event&#x60; with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1)
      , callbacks = this._callbacks[event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i &lt; len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for &#x60;event&#x60;.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[event] || [];
  };

  /**
   * Check if this emitter has &#x60;event&#x60; handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };

},{}],16:[function(_dereq_,module,exports){

  module.exports = function(a, b){
    var fn = function(){};
    fn.prototype = b.prototype;
    a.prototype = new fn;
    a.prototype.constructor = a;
  };
},{}],17:[function(_dereq_,module,exports){

  /**
   * This is the web browser implementation of &#x60;debug()&#x60;.
   *
   * Expose &#x60;debug()&#x60; as the module.
   */

  exports = module.exports = _dereq_(&#x27;./debug&#x27;);
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = &#x27;undefined&#x27; != typeof chrome
  &amp;&amp; &#x27;undefined&#x27; != typeof chrome.storage
    ? chrome.storage.local
    : localstorage();

  /**
   * Colors.
   */

  exports.colors = [
    &#x27;lightseagreen&#x27;,
    &#x27;forestgreen&#x27;,
    &#x27;goldenrod&#x27;,
    &#x27;dodgerblue&#x27;,
    &#x27;darkorchid&#x27;,
    &#x27;crimson&#x27;
  ];

  /**
   * Currently only WebKit-based Web Inspectors, Firefox &gt;= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support &quot;%c&quot; CSS customizations.
   *
   * TODO: add a &#x60;localStorage&#x60; variable to explicitly enable/disable colors
   */

  function useColors() {
    // is webkit? http://stackoverflow.com/a/16459606/376773
    return (&#x27;WebkitAppearance&#x27; in document.documentElement.style) ||
        // is firebug? http://stackoverflow.com/a/398120/376773
      (window.console &amp;&amp; (console.firebug || (console.exception &amp;&amp; console.table))) ||
        // is firefox &gt;= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) &amp;&amp; parseInt(RegExp.$1, 10) &gt;= 31);
  }

  /**
   * Map %j to &#x60;JSON.stringify()&#x60;, since no Web Inspectors do that by default.
   */

  exports.formatters.j = function(v) {
    return JSON.stringify(v);
  };


  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */

  function formatArgs() {
    var args = arguments;
    var useColors = this.useColors;

    args[0] = (useColors ? &#x27;%c&#x27; : &#x27;&#x27;)
      + this.namespace
      + (useColors ? &#x27; %c&#x27; : &#x27; &#x27;)
      + args[0]
      + (useColors ? &#x27;%c &#x27; : &#x27; &#x27;)
      + &#x27;+&#x27; + exports.humanize(this.diff);

    if (!useColors) return args;

    var c = &#x27;color: &#x27; + this.color;
    args = [args[0], c, &#x27;color: inherit&#x27;].concat(Array.prototype.slice.call(args, 1));

    // the final &quot;%c&quot; is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-z%]/g, function(match) {
      if (&#x27;%%&#x27; === match) return;
      index++;
      if (&#x27;%c&#x27; === match) {
        // we only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });

    args.splice(lastC, 0, c);
    return args;
  }

  /**
   * Invokes &#x60;console.log()&#x60; when available.
   * No-op when &#x60;console.log&#x60; is not a &quot;function&quot;.
   *
   * @api public
   */

  function log() {
    // this hackery is required for IE8/9, where
    // the &#x60;console.log&#x60; function doesn&#x27;t have &#x27;apply&#x27;
    return &#x27;object&#x27; === typeof console
      &amp;&amp; console.log
      &amp;&amp; Function.prototype.apply.call(console.log, console, arguments);
  }

  /**
   * Save &#x60;namespaces&#x60;.
   *
   * @param {String} namespaces
   * @api private
   */

  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem(&#x27;debug&#x27;);
      } else {
        exports.storage.debug = namespaces;
      }
    } catch(e) {}
  }

  /**
   * Load &#x60;namespaces&#x60;.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */

  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch(e) {}
    return r;
  }

  /**
   * Enable namespaces listed in &#x60;localStorage.debug&#x60; initially.
   */

  exports.enable(load());

  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */

  function localstorage(){
    try {
      return window.localStorage;
    } catch (e) {}
  }

},{&quot;./debug&quot;:18}],18:[function(_dereq_,module,exports){

  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of &#x60;debug()&#x60;.
   *
   * Expose &#x60;debug()&#x60; as the module.
   */

  exports = module.exports = debug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = _dereq_(&#x27;ms&#x27;);

  /**
   * The currently active debug mode names, and names to skip.
   */

  exports.names = [];
  exports.skips = [];

  /**
   * Map of special &quot;%n&quot; handling functions, for the debug &quot;format&quot; argument.
   *
   * Valid key names are a single, lowercased letter, i.e. &quot;n&quot;.
   */

  exports.formatters = {};

  /**
   * Previously assigned color.
   */

  var prevColor = 0;

  /**
   * Previous log timestamp.
   */

  var prevTime;

  /**
   * Select a color.
   *
   * @return {Number}
   * @api private
   */

  function selectColor() {
    return exports.colors[prevColor++ % exports.colors.length];
  }

  /**
   * Create a debugger with the given &#x60;namespace&#x60;.
   *
   * @param {String} namespace
   * @return {Function}
   * @api public
   */

  function debug(namespace) {

    // define the &#x60;disabled&#x60; version
    function disabled() {
    }
    disabled.enabled = false;

    // define the &#x60;enabled&#x60; version
    function enabled() {

      var self = enabled;

      // set &#x60;diff&#x60; timestamp
      var curr = +new Date();
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;

      // add the &#x60;color&#x60; if not set
      if (null == self.useColors) self.useColors = exports.useColors();
      if (null == self.color &amp;&amp; self.useColors) self.color = selectColor();

      var args = Array.prototype.slice.call(arguments);

      args[0] = exports.coerce(args[0]);

      if (&#x27;string&#x27; !== typeof args[0]) {
        // anything else let&#x27;s inspect with %o
        args = [&#x27;%o&#x27;].concat(args);
      }

      // apply any &#x60;formatters&#x60; transformations
      var index = 0;
      args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
        // if we encounter an escaped % then don&#x27;t increase the array index
        if (match === &#x27;%%&#x27;) return match;
        index++;
        var formatter = exports.formatters[format];
        if (&#x27;function&#x27; === typeof formatter) {
          var val = args[index];
          match = formatter.call(self, val);

          // now we need to remove &#x60;args[index]&#x60; since it&#x27;s inlined in the &#x60;format&#x60;
          args.splice(index, 1);
          index--;
        }
        return match;
      });

      if (&#x27;function&#x27; === typeof exports.formatArgs) {
        args = exports.formatArgs.apply(self, args);
      }
      var logFn = enabled.log || exports.log || console.log.bind(console);
      logFn.apply(self, args);
    }
    enabled.enabled = true;

    var fn = exports.enabled(namespace) ? enabled : disabled;

    fn.namespace = namespace;

    return fn;
  }

  /**
   * Enables a debug mode by namespaces. This can include modes
   * separated by a colon and wildcards.
   *
   * @param {String} namespaces
   * @api public
   */

  function enable(namespaces) {
    exports.save(namespaces);

    var split = (namespaces || &#x27;&#x27;).split(/[\s,]+/);
    var len = split.length;

    for (var i = 0; i &lt; len; i++) {
      if (!split[i]) continue; // ignore empty strings
      namespaces = split[i].replace(/\*/g, &#x27;.*?&#x27;);
      if (namespaces[0] === &#x27;-&#x27;) {
        exports.skips.push(new RegExp(&#x27;^&#x27; + namespaces.substr(1) + &#x27;$&#x27;));
      } else {
        exports.names.push(new RegExp(&#x27;^&#x27; + namespaces + &#x27;$&#x27;));
      }
    }
  }

  /**
   * Disable debug output.
   *
   * @api public
   */

  function disable() {
    exports.enable(&#x27;&#x27;);
  }

  /**
   * Returns true if the given mode name is enabled, false otherwise.
   *
   * @param {String} name
   * @return {Boolean}
   * @api public
   */

  function enabled(name) {
    var i, len;
    for (i = 0, len = exports.skips.length; i &lt; len; i++) {
      if (exports.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = exports.names.length; i &lt; len; i++) {
      if (exports.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Coerce &#x60;val&#x60;.
   *
   * @param {Mixed} val
   * @return {Mixed}
   * @api private
   */

  function coerce(val) {
    if (val instanceof Error) return val.stack || val.message;
    return val;
  }

},{&quot;ms&quot;:25}],19:[function(_dereq_,module,exports){
  (function (global){
    /**
     * Module dependencies.
     */

    var keys = _dereq_(&#x27;./keys&#x27;);
    var hasBinary = _dereq_(&#x27;has-binary&#x27;);
    var sliceBuffer = _dereq_(&#x27;arraybuffer.slice&#x27;);
    var base64encoder = _dereq_(&#x27;base64-arraybuffer&#x27;);
    var after = _dereq_(&#x27;after&#x27;);
    var utf8 = _dereq_(&#x27;utf8&#x27;);

    /**
     * Check if we are running an android browser. That requires us to use
     * ArrayBuffer with polling transports...
     *
     * http://ghinda.net/jpeg-blob-ajax-android/
     */

    var isAndroid = navigator.userAgent.match(/Android/i);

    /**
     * Check if we are running in PhantomJS.
     * Uploading a Blob with PhantomJS does not work correctly, as reported here:
     * https://github.com/ariya/phantomjs/issues/11395
     * @type boolean
     */
    var isPhantomJS = /PhantomJS/i.test(navigator.userAgent);

    /**
     * When true, avoids using Blobs to encode payloads.
     * @type boolean
     */
    var dontSendBlobs = isAndroid || isPhantomJS;

    /**
     * Current protocol version.
     */

    exports.protocol = 3;

    /**
     * Packet types.
     */

    var packets = exports.packets = {
      open:     0    // non-ws
      , close:    1    // non-ws
      , ping:     2
      , pong:     3
      , message:  4
      , upgrade:  5
      , noop:     6
    };

    var packetslist = keys(packets);

    /**
     * Premade error packet.
     */

    var err = { type: &#x27;error&#x27;, data: &#x27;parser error&#x27; };

    /**
     * Create a blob api even for blob builder when vendor prefixes exist
     */

    var Blob = _dereq_(&#x27;blob&#x27;);

    /**
     * Encodes a packet.
     *
     *     &lt;packet type id&gt; [ &lt;data&gt; ]
     *
     * Example:
     *
     *     5hello world
     *     3
     *     4
     *
     * Binary is encoded in an identical principle
     *
     * @api private
     */

    exports.encodePacket = function (packet, supportsBinary, utf8encode, callback) {
      if (&#x27;function&#x27; == typeof supportsBinary) {
        callback = supportsBinary;
        supportsBinary = false;
      }

      if (&#x27;function&#x27; == typeof utf8encode) {
        callback = utf8encode;
        utf8encode = null;
      }

      var data = (packet.data === undefined)
        ? undefined
        : packet.data.buffer || packet.data;

      if (global.ArrayBuffer &amp;&amp; data instanceof ArrayBuffer) {
        return encodeArrayBuffer(packet, supportsBinary, callback);
      } else if (Blob &amp;&amp; data instanceof global.Blob) {
        return encodeBlob(packet, supportsBinary, callback);
      }

      // might be an object with { base64: true, data: dataAsBase64String }
      if (data &amp;&amp; data.base64) {
        return encodeBase64Object(packet, callback);
      }

      // Sending data as a utf-8 string
      var encoded = packets[packet.type];

      // data fragment is optional
      if (undefined !== packet.data) {
        encoded += utf8encode ? utf8.encode(String(packet.data)) : String(packet.data);
      }

      return callback(&#x27;&#x27; + encoded);

    };

    function encodeBase64Object(packet, callback) {
      // packet data is an object { base64: true, data: dataAsBase64String }
      var message = &#x27;b&#x27; + exports.packets[packet.type] + packet.data.data;
      return callback(message);
    }

    /**
     * Encode packet helpers for binary types
     */

    function encodeArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      var data = packet.data;
      var contentArray = new Uint8Array(data);
      var resultBuffer = new Uint8Array(1 + data.byteLength);

      resultBuffer[0] = packets[packet.type];
      for (var i = 0; i &lt; contentArray.length; i++) {
        resultBuffer[i+1] = contentArray[i];
      }

      return callback(resultBuffer.buffer);
    }

    function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      var fr = new FileReader();
      fr.onload = function() {
        packet.data = fr.result;
        exports.encodePacket(packet, supportsBinary, true, callback);
      };
      return fr.readAsArrayBuffer(packet.data);
    }

    function encodeBlob(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }

      if (dontSendBlobs) {
        return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
      }

      var length = new Uint8Array(1);
      length[0] = packets[packet.type];
      var blob = new Blob([length.buffer, packet.data]);

      return callback(blob);
    }

    /**
     * Encodes a packet with binary data in a base64 string
     *
     * @param {Object} packet, has &#x60;type&#x60; and &#x60;data&#x60;
     * @return {String} base64 encoded message
     */

    exports.encodeBase64Packet = function(packet, callback) {
      var message = &#x27;b&#x27; + exports.packets[packet.type];
      if (Blob &amp;&amp; packet.data instanceof global.Blob) {
        var fr = new FileReader();
        fr.onload = function() {
          var b64 = fr.result.split(&#x27;,&#x27;)[1];
          callback(message + b64);
        };
        return fr.readAsDataURL(packet.data);
      }

      var b64data;
      try {
        b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
      } catch (e) {
        // iPhone Safari doesn&#x27;t let you apply with typed arrays
        var typed = new Uint8Array(packet.data);
        var basic = new Array(typed.length);
        for (var i = 0; i &lt; typed.length; i++) {
          basic[i] = typed[i];
        }
        b64data = String.fromCharCode.apply(null, basic);
      }
      message += global.btoa(b64data);
      return callback(message);
    };

    /**
     * Decodes a packet. Changes format to Blob if requested.
     *
     * @return {Object} with &#x60;type&#x60; and &#x60;data&#x60; (if any)
     * @api private
     */

    exports.decodePacket = function (data, binaryType, utf8decode) {
      // String data
      if (typeof data == &#x27;string&#x27; || data === undefined) {
        if (data.charAt(0) == &#x27;b&#x27;) {
          return exports.decodeBase64Packet(data.substr(1), binaryType);
        }

        if (utf8decode) {
          try {
            data = utf8.decode(data);
          } catch (e) {
            return err;
          }
        }
        var type = data.charAt(0);

        if (Number(type) != type || !packetslist[type]) {
          return err;
        }

        if (data.length &gt; 1) {
          return { type: packetslist[type], data: data.substring(1) };
        } else {
          return { type: packetslist[type] };
        }
      }

      var asArray = new Uint8Array(data);
      var type = asArray[0];
      var rest = sliceBuffer(data, 1);
      if (Blob &amp;&amp; binaryType === &#x27;blob&#x27;) {
        rest = new Blob([rest]);
      }
      return { type: packetslist[type], data: rest };
    };

    /**
     * Decodes a packet encoded in a base64 string
     *
     * @param {String} base64 encoded message
     * @return {Object} with &#x60;type&#x60; and &#x60;data&#x60; (if any)
     */

    exports.decodeBase64Packet = function(msg, binaryType) {
      var type = packetslist[msg.charAt(0)];
      if (!global.ArrayBuffer) {
        return { type: type, data: { base64: true, data: msg.substr(1) } };
      }

      var data = base64encoder.decode(msg.substr(1));

      if (binaryType === &#x27;blob&#x27; &amp;&amp; Blob) {
        data = new Blob([data]);
      }

      return { type: type, data: data };
    };

    /**
     * Encodes multiple messages (payload).
     *
     *     &lt;length&gt;:data
     *
     * Example:
     *
     *     11:hello world2:hi
     *
     * If any contents are binary, they will be encoded as base64 strings. Base64
     * encoded strings are marked with a b before the length specifier
     *
     * @param {Array} packets
     * @api private
     */

    exports.encodePayload = function (packets, supportsBinary, callback) {
      if (typeof supportsBinary == &#x27;function&#x27;) {
        callback = supportsBinary;
        supportsBinary = null;
      }

      var isBinary = hasBinary(packets);

      if (supportsBinary &amp;&amp; isBinary) {
        if (Blob &amp;&amp; !dontSendBlobs) {
          return exports.encodePayloadAsBlob(packets, callback);
        }

        return exports.encodePayloadAsArrayBuffer(packets, callback);
      }

      if (!packets.length) {
        return callback(&#x27;0:&#x27;);
      }

      function setLengthHeader(message) {
        return message.length + &#x27;:&#x27; + message;
      }

      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, !isBinary ? false : supportsBinary, true, function(message) {
          doneCallback(null, setLengthHeader(message));
        });
      }

      map(packets, encodeOne, function(err, results) {
        return callback(results.join(&#x27;&#x27;));
      });
    };

    /**
     * Async array map using after
     */

    function map(ary, each, done) {
      var result = new Array(ary.length);
      var next = after(ary.length, done);

      var eachWithIndex = function(i, el, cb) {
        each(el, function(error, msg) {
          result[i] = msg;
          cb(error, result);
        });
      };

      for (var i = 0; i &lt; ary.length; i++) {
        eachWithIndex(i, ary[i], next);
      }
    }

    /*
     * Decodes data when a payload is maybe expected. Possible binary contents are
     * decoded from their base64 representation
     *
     * @param {String} data, callback method
     * @api public
     */

    exports.decodePayload = function (data, binaryType, callback) {
      if (typeof data != &#x27;string&#x27;) {
        return exports.decodePayloadAsBinary(data, binaryType, callback);
      }

      if (typeof binaryType === &#x27;function&#x27;) {
        callback = binaryType;
        binaryType = null;
      }

      var packet;
      if (data == &#x27;&#x27;) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

      var length = &#x27;&#x27;
        , n, msg;

      for (var i = 0, l = data.length; i &lt; l; i++) {
        var chr = data.charAt(i);

        if (&#x27;:&#x27; != chr) {
          length += chr;
        } else {
          if (&#x27;&#x27; == length || (length != (n = Number(length)))) {
            // parser error - ignoring payload
            return callback(err, 0, 1);
          }

          msg = data.substr(i + 1, n);

          if (length != msg.length) {
            // parser error - ignoring payload
            return callback(err, 0, 1);
          }

          if (msg.length) {
            packet = exports.decodePacket(msg, binaryType, true);

            if (err.type == packet.type &amp;&amp; err.data == packet.data) {
              // parser error in individual packet - ignoring payload
              return callback(err, 0, 1);
            }

            var ret = callback(packet, i + n, l);
            if (false === ret) return;
          }

          // advance cursor
          i += n;
          length = &#x27;&#x27;;
        }
      }

      if (length != &#x27;&#x27;) {
        // parser error - ignoring payload
        return callback(err, 0, 1);
      }

    };

    /**
     * Encodes multiple messages (payload) as binary.
     *
     * &lt;1 = binary, 0 = string&gt;&lt;number from 0-9&gt;&lt;number from 0-9&gt;[...]&lt;number
     * 255&gt;&lt;data&gt;
     *
     * Example:
     * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
     *
     * @param {Array} packets
     * @return {ArrayBuffer} encoded payload
     * @api private
     */

    exports.encodePayloadAsArrayBuffer = function(packets, callback) {
      if (!packets.length) {
        return callback(new ArrayBuffer(0));
      }

      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(data) {
          return doneCallback(null, data);
        });
      }

      map(packets, encodeOne, function(err, encodedPackets) {
        var totalLength = encodedPackets.reduce(function(acc, p) {
          var len;
          if (typeof p === &#x27;string&#x27;){
            len = p.length;
          } else {
            len = p.byteLength;
          }
          return acc + len.toString().length + len + 2; // string/binary identifier + separator = 2
        }, 0);

        var resultArray = new Uint8Array(totalLength);

        var bufferIndex = 0;
        encodedPackets.forEach(function(p) {
          var isString = typeof p === &#x27;string&#x27;;
          var ab = p;
          if (isString) {
            var view = new Uint8Array(p.length);
            for (var i = 0; i &lt; p.length; i++) {
              view[i] = p.charCodeAt(i);
            }
            ab = view.buffer;
          }

          if (isString) { // not true binary
            resultArray[bufferIndex++] = 0;
          } else { // true binary
            resultArray[bufferIndex++] = 1;
          }

          var lenStr = ab.byteLength.toString();
          for (var i = 0; i &lt; lenStr.length; i++) {
            resultArray[bufferIndex++] = parseInt(lenStr[i]);
          }
          resultArray[bufferIndex++] = 255;

          var view = new Uint8Array(ab);
          for (var i = 0; i &lt; view.length; i++) {
            resultArray[bufferIndex++] = view[i];
          }
        });

        return callback(resultArray.buffer);
      });
    };

    /**
     * Encode as Blob
     */

    exports.encodePayloadAsBlob = function(packets, callback) {
      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(encoded) {
          var binaryIdentifier = new Uint8Array(1);
          binaryIdentifier[0] = 1;
          if (typeof encoded === &#x27;string&#x27;) {
            var view = new Uint8Array(encoded.length);
            for (var i = 0; i &lt; encoded.length; i++) {
              view[i] = encoded.charCodeAt(i);
            }
            encoded = view.buffer;
            binaryIdentifier[0] = 0;
          }

          var len = (encoded instanceof ArrayBuffer)
            ? encoded.byteLength
            : encoded.size;

          var lenStr = len.toString();
          var lengthAry = new Uint8Array(lenStr.length + 1);
          for (var i = 0; i &lt; lenStr.length; i++) {
            lengthAry[i] = parseInt(lenStr[i]);
          }
          lengthAry[lenStr.length] = 255;

          if (Blob) {
            var blob = new Blob([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
            doneCallback(null, blob);
          }
        });
      }

      map(packets, encodeOne, function(err, results) {
        return callback(new Blob(results));
      });
    };

    /*
     * Decodes data when a payload is maybe expected. Strings are decoded by
     * interpreting each byte as a key code for entries marked to start with 0. See
     * description of encodePayloadAsBinary
     *
     * @param {ArrayBuffer} data, callback method
     * @api public
     */

    exports.decodePayloadAsBinary = function (data, binaryType, callback) {
      if (typeof binaryType === &#x27;function&#x27;) {
        callback = binaryType;
        binaryType = null;
      }

      var bufferTail = data;
      var buffers = [];

      var numberTooLong = false;
      while (bufferTail.byteLength &gt; 0) {
        var tailArray = new Uint8Array(bufferTail);
        var isString = tailArray[0] === 0;
        var msgLength = &#x27;&#x27;;

        for (var i = 1; ; i++) {
          if (tailArray[i] == 255) break;

          if (msgLength.length &gt; 310) {
            numberTooLong = true;
            break;
          }

          msgLength += tailArray[i];
        }

        if(numberTooLong) return callback(err, 0, 1);

        bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
        msgLength = parseInt(msgLength);

        var msg = sliceBuffer(bufferTail, 0, msgLength);
        if (isString) {
          try {
            msg = String.fromCharCode.apply(null, new Uint8Array(msg));
          } catch (e) {
            // iPhone Safari doesn&#x27;t let you apply to typed arrays
            var typed = new Uint8Array(msg);
            msg = &#x27;&#x27;;
            for (var i = 0; i &lt; typed.length; i++) {
              msg += String.fromCharCode(typed[i]);
            }
          }
        }

        buffers.push(msg);
        bufferTail = sliceBuffer(bufferTail, msgLength);
      }

      var total = buffers.length;
      buffers.forEach(function(buffer, i) {
        callback(exports.decodePacket(buffer, binaryType, true), i, total);
      });
    };

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;./keys&quot;:20,&quot;after&quot;:11,&quot;arraybuffer.slice&quot;:12,&quot;base64-arraybuffer&quot;:13,&quot;blob&quot;:14,&quot;has-binary&quot;:21,&quot;utf8&quot;:29}],20:[function(_dereq_,module,exports){

  /**
   * Gets the keys for an object.
   *
   * @return {Array} keys
   * @api private
   */

  module.exports = Object.keys || function keys (obj){
      var arr = [];
      var has = Object.prototype.hasOwnProperty;

      for (var i in obj) {
        if (has.call(obj, i)) {
          arr.push(i);
        }
      }
      return arr;
    };

},{}],21:[function(_dereq_,module,exports){
  (function (global){

    /*
     * Module requirements.
     */

    var isArray = _dereq_(&#x27;isarray&#x27;);

    /**
     * Module exports.
     */

    module.exports = hasBinary;

    /**
     * Checks for binary data.
     *
     * Right now only Buffer and ArrayBuffer are supported..
     *
     * @param {Object} anything
     * @api public
     */

    function hasBinary(data) {

      function _hasBinary(obj) {
        if (!obj) return false;

        if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
          (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
          (global.Blob &amp;&amp; obj instanceof Blob) ||
          (global.File &amp;&amp; obj instanceof File)
        ) {
          return true;
        }

        if (isArray(obj)) {
          for (var i = 0; i &lt; obj.length; i++) {
            if (_hasBinary(obj[i])) {
              return true;
            }
          }
        } else if (obj &amp;&amp; &#x27;object&#x27; == typeof obj) {
          if (obj.toJSON) {
            obj = obj.toJSON();
          }

          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {
              return true;
            }
          }
        }

        return false;
      }

      return _hasBinary(data);
    }

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;isarray&quot;:24}],22:[function(_dereq_,module,exports){

  /**
   * Module exports.
   *
   * Logic borrowed from Modernizr:
   *
   *   - https://github.com/Modernizr/Modernizr/blob/master/feature-detects/cors.js
   */

  try {
    module.exports = typeof XMLHttpRequest !== &#x27;undefined&#x27; &amp;&amp;
      &#x27;withCredentials&#x27; in new XMLHttpRequest();
  } catch (err) {
    // if XMLHttp support is disabled in IE then it will throw
    // when trying to create
    module.exports = false;
  }

},{}],23:[function(_dereq_,module,exports){

  var indexOf = [].indexOf;

  module.exports = function(arr, obj){
    if (indexOf) return arr.indexOf(obj);
    for (var i = 0; i &lt; arr.length; ++i) {
      if (arr[i] === obj) return i;
    }
    return -1;
  };
},{}],24:[function(_dereq_,module,exports){
  module.exports = Array.isArray || function (arr) {
      return Object.prototype.toString.call(arr) == &#x27;[object Array]&#x27;;
    };

},{}],25:[function(_dereq_,module,exports){
  /**
   * Helpers.
   */

  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var y = d * 365.25;

  /**
   * Parse or format the given &#x60;val&#x60;.
   *
   * Options:
   *
   *  - &#x60;long&#x60; verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} options
   * @return {String|Number}
   * @api public
   */

  module.exports = function(val, options){
    options = options || {};
    if (&#x27;string&#x27; == typeof val) return parse(val);
    return options.long
      ? long(val)
      : short(val);
  };

  /**
   * Parse the given &#x60;str&#x60; and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */

  function parse(str) {
    str = &#x27;&#x27; + str;
    if (str.length &gt; 10000) return;
    var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
    if (!match) return;
    var n = parseFloat(match[1]);
    var type = (match[2] || &#x27;ms&#x27;).toLowerCase();
    switch (type) {
      case &#x27;years&#x27;:
      case &#x27;year&#x27;:
      case &#x27;yrs&#x27;:
      case &#x27;yr&#x27;:
      case &#x27;y&#x27;:
        return n * y;
      case &#x27;days&#x27;:
      case &#x27;day&#x27;:
      case &#x27;d&#x27;:
        return n * d;
      case &#x27;hours&#x27;:
      case &#x27;hour&#x27;:
      case &#x27;hrs&#x27;:
      case &#x27;hr&#x27;:
      case &#x27;h&#x27;:
        return n * h;
      case &#x27;minutes&#x27;:
      case &#x27;minute&#x27;:
      case &#x27;mins&#x27;:
      case &#x27;min&#x27;:
      case &#x27;m&#x27;:
        return n * m;
      case &#x27;seconds&#x27;:
      case &#x27;second&#x27;:
      case &#x27;secs&#x27;:
      case &#x27;sec&#x27;:
      case &#x27;s&#x27;:
        return n * s;
      case &#x27;milliseconds&#x27;:
      case &#x27;millisecond&#x27;:
      case &#x27;msecs&#x27;:
      case &#x27;msec&#x27;:
      case &#x27;ms&#x27;:
        return n;
    }
  }

  /**
   * Short format for &#x60;ms&#x60;.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function short(ms) {
    if (ms &gt;= d) return Math.round(ms / d) + &#x27;d&#x27;;
    if (ms &gt;= h) return Math.round(ms / h) + &#x27;h&#x27;;
    if (ms &gt;= m) return Math.round(ms / m) + &#x27;m&#x27;;
    if (ms &gt;= s) return Math.round(ms / s) + &#x27;s&#x27;;
    return ms + &#x27;ms&#x27;;
  }

  /**
   * Long format for &#x60;ms&#x60;.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */

  function long(ms) {
    return plural(ms, d, &#x27;day&#x27;)
      || plural(ms, h, &#x27;hour&#x27;)
      || plural(ms, m, &#x27;minute&#x27;)
      || plural(ms, s, &#x27;second&#x27;)
      || ms + &#x27; ms&#x27;;
  }

  /**
   * Pluralization helper.
   */

  function plural(ms, n, name) {
    if (ms &lt; n) return;
    if (ms &lt; n * 1.5) return Math.floor(ms / n) + &#x27; &#x27; + name;
    return Math.ceil(ms / n) + &#x27; &#x27; + name + &#x27;s&#x27;;
  }

},{}],26:[function(_dereq_,module,exports){
  (function (global){
    /**
     * JSON parse.
     *
     * @see Based on jQuery#parseJSON (MIT) and JSON2
     * @api private
     */

    var rvalidchars = /^[\],:{}\s]*$/;
    var rvalidescape = /\\(?:[&quot;\\\/bfnrt]|u[0-9a-fA-F]{4})/g;
    var rvalidtokens = /&quot;[^&quot;\\\n\r]*&quot;|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g;
    var rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;
    var rtrimLeft = /^\s+/;
    var rtrimRight = /\s+$/;

    module.exports = function parsejson(data) {
      if (&#x27;string&#x27; != typeof data || !data) {
        return null;
      }

      data = data.replace(rtrimLeft, &#x27;&#x27;).replace(rtrimRight, &#x27;&#x27;);

      // Attempt to parse using the native JSON parser first
      if (global.JSON &amp;&amp; JSON.parse) {
        return JSON.parse(data);
      }

      if (rvalidchars.test(data.replace(rvalidescape, &#x27;@&#x27;)
          .replace(rvalidtokens, &#x27;]&#x27;)
          .replace(rvalidbraces, &#x27;&#x27;))) {
        return (new Function(&#x27;return &#x27; + data))();
      }
    };
  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{}],27:[function(_dereq_,module,exports){
  /**
   * Compiles a querystring
   * Returns string representation of the object
   *
   * @param {Object}
   * @api private
   */

  exports.encode = function (obj) {
    var str = &#x27;&#x27;;

    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length) str += &#x27;&amp;&#x27;;
        str += encodeURIComponent(i) + &#x27;=&#x27; + encodeURIComponent(obj[i]);
      }
    }

    return str;
  };

  /**
   * Parses a simple querystring into an object
   *
   * @param {String} qs
   * @api private
   */

  exports.decode = function(qs){
    var qry = {};
    var pairs = qs.split(&#x27;&amp;&#x27;);
    for (var i = 0, l = pairs.length; i &lt; l; i++) {
      var pair = pairs[i].split(&#x27;=&#x27;);
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  };

},{}],28:[function(_dereq_,module,exports){
  /**
   * Parses an URI
   *
   * @author Steven Levithan &lt;stevenlevithan.com&gt; (MIT license)
   * @api private
   */

  var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;

  var parts = [
    &#x27;source&#x27;, &#x27;protocol&#x27;, &#x27;authority&#x27;, &#x27;userInfo&#x27;, &#x27;user&#x27;, &#x27;password&#x27;, &#x27;host&#x27;, &#x27;port&#x27;, &#x27;relative&#x27;, &#x27;path&#x27;, &#x27;directory&#x27;, &#x27;file&#x27;, &#x27;query&#x27;, &#x27;anchor&#x27;
  ];

  module.exports = function parseuri(str) {
    var src = str,
      b = str.indexOf(&#x27;[&#x27;),
      e = str.indexOf(&#x27;]&#x27;);

    if (b != -1 &amp;&amp; e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, &#x27;;&#x27;) + str.substring(e, str.length);
    }

    var m = re.exec(str || &#x27;&#x27;),
      uri = {},
      i = 14;

    while (i--) {
      uri[parts[i]] = m[i] || &#x27;&#x27;;
    }

    if (b != -1 &amp;&amp; e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, &#x27;:&#x27;);
      uri.authority = uri.authority.replace(&#x27;[&#x27;, &#x27;&#x27;).replace(&#x27;]&#x27;, &#x27;&#x27;).replace(/;/g, &#x27;:&#x27;);
      uri.ipv6uri = true;
    }

    return uri;
  };

},{}],29:[function(_dereq_,module,exports){
  (function (global){
    /*! https://mths.be/utf8js v2.0.0 by @mathias */
    ;(function(root) {

      // Detect free variables &#x60;exports&#x60;
      var freeExports = typeof exports == &#x27;object&#x27; &amp;&amp; exports;

      // Detect free variable &#x60;module&#x60;
      var freeModule = typeof module == &#x27;object&#x27; &amp;&amp; module &amp;&amp;
        module.exports == freeExports &amp;&amp; module;

      // Detect free variable &#x60;global&#x60;, from Node.js or Browserified code,
      // and use it as &#x60;root&#x60;
      var freeGlobal = typeof global == &#x27;object&#x27; &amp;&amp; global;
      if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
        root = freeGlobal;
      }

      /*--------------------------------------------------------------------------*/

      var stringFromCharCode = String.fromCharCode;

      // Taken from https://mths.be/punycode
      function ucs2decode(string) {
        var output = [];
        var counter = 0;
        var length = string.length;
        var value;
        var extra;
        while (counter &lt; length) {
          value = string.charCodeAt(counter++);
          if (value &gt;= 0xD800 &amp;&amp; value &lt;= 0xDBFF &amp;&amp; counter &lt; length) {
            // high surrogate, and there is a next character
            extra = string.charCodeAt(counter++);
            if ((extra &amp; 0xFC00) == 0xDC00) { // low surrogate
              output.push(((value &amp; 0x3FF) &lt;&lt; 10) + (extra &amp; 0x3FF) + 0x10000);
            } else {
              // unmatched surrogate; only append this code unit, in case the next
              // code unit is the high surrogate of a surrogate pair
              output.push(value);
              counter--;
            }
          } else {
            output.push(value);
          }
        }
        return output;
      }

      // Taken from https://mths.be/punycode
      function ucs2encode(array) {
        var length = array.length;
        var index = -1;
        var value;
        var output = &#x27;&#x27;;
        while (++index &lt; length) {
          value = array[index];
          if (value &gt; 0xFFFF) {
            value -= 0x10000;
            output += stringFromCharCode(value &gt;&gt;&gt; 10 &amp; 0x3FF | 0xD800);
            value = 0xDC00 | value &amp; 0x3FF;
          }
          output += stringFromCharCode(value);
        }
        return output;
      }

      function checkScalarValue(codePoint) {
        if (codePoint &gt;= 0xD800 &amp;&amp; codePoint &lt;= 0xDFFF) {
          throw Error(
            &#x27;Lone surrogate U+&#x27; + codePoint.toString(16).toUpperCase() +
            &#x27; is not a scalar value&#x27;
          );
        }
      }
      /*--------------------------------------------------------------------------*/

      function createByte(codePoint, shift) {
        return stringFromCharCode(((codePoint &gt;&gt; shift) &amp; 0x3F) | 0x80);
      }

      function encodeCodePoint(codePoint) {
        if ((codePoint &amp; 0xFFFFFF80) == 0) { // 1-byte sequence
          return stringFromCharCode(codePoint);
        }
        var symbol = &#x27;&#x27;;
        if ((codePoint &amp; 0xFFFFF800) == 0) { // 2-byte sequence
          symbol = stringFromCharCode(((codePoint &gt;&gt; 6) &amp; 0x1F) | 0xC0);
        }
        else if ((codePoint &amp; 0xFFFF0000) == 0) { // 3-byte sequence
          checkScalarValue(codePoint);
          symbol = stringFromCharCode(((codePoint &gt;&gt; 12) &amp; 0x0F) | 0xE0);
          symbol += createByte(codePoint, 6);
        }
        else if ((codePoint &amp; 0xFFE00000) == 0) { // 4-byte sequence
          symbol = stringFromCharCode(((codePoint &gt;&gt; 18) &amp; 0x07) | 0xF0);
          symbol += createByte(codePoint, 12);
          symbol += createByte(codePoint, 6);
        }
        symbol += stringFromCharCode((codePoint &amp; 0x3F) | 0x80);
        return symbol;
      }

      function utf8encode(string) {
        var codePoints = ucs2decode(string);
        var length = codePoints.length;
        var index = -1;
        var codePoint;
        var byteString = &#x27;&#x27;;
        while (++index &lt; length) {
          codePoint = codePoints[index];
          byteString += encodeCodePoint(codePoint);
        }
        return byteString;
      }

      /*--------------------------------------------------------------------------*/

      function readContinuationByte() {
        if (byteIndex &gt;= byteCount) {
          throw Error(&#x27;Invalid byte index&#x27;);
        }

        var continuationByte = byteArray[byteIndex] &amp; 0xFF;
        byteIndex++;

        if ((continuationByte &amp; 0xC0) == 0x80) {
          return continuationByte &amp; 0x3F;
        }

        // If we end up here, itâ€™s not a continuation byte
        throw Error(&#x27;Invalid continuation byte&#x27;);
      }

      function decodeSymbol() {
        var byte1;
        var byte2;
        var byte3;
        var byte4;
        var codePoint;

        if (byteIndex &gt; byteCount) {
          throw Error(&#x27;Invalid byte index&#x27;);
        }

        if (byteIndex == byteCount) {
          return false;
        }

        // Read first byte
        byte1 = byteArray[byteIndex] &amp; 0xFF;
        byteIndex++;

        // 1-byte sequence (no continuation bytes)
        if ((byte1 &amp; 0x80) == 0) {
          return byte1;
        }

        // 2-byte sequence
        if ((byte1 &amp; 0xE0) == 0xC0) {
          var byte2 = readContinuationByte();
          codePoint = ((byte1 &amp; 0x1F) &lt;&lt; 6) | byte2;
          if (codePoint &gt;= 0x80) {
            return codePoint;
          } else {
            throw Error(&#x27;Invalid continuation byte&#x27;);
          }
        }

        // 3-byte sequence (may include unpaired surrogates)
        if ((byte1 &amp; 0xF0) == 0xE0) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 12) | (byte2 &lt;&lt; 6) | byte3;
          if (codePoint &gt;= 0x0800) {
            checkScalarValue(codePoint);
            return codePoint;
          } else {
            throw Error(&#x27;Invalid continuation byte&#x27;);
          }
        }

        // 4-byte sequence
        if ((byte1 &amp; 0xF8) == 0xF0) {
          byte2 = readContinuationByte();
          byte3 = readContinuationByte();
          byte4 = readContinuationByte();
          codePoint = ((byte1 &amp; 0x0F) &lt;&lt; 0x12) | (byte2 &lt;&lt; 0x0C) |
            (byte3 &lt;&lt; 0x06) | byte4;
          if (codePoint &gt;= 0x010000 &amp;&amp; codePoint &lt;= 0x10FFFF) {
            return codePoint;
          }
        }

        throw Error(&#x27;Invalid UTF-8 detected&#x27;);
      }

      var byteArray;
      var byteCount;
      var byteIndex;
      function utf8decode(byteString) {
        byteArray = ucs2decode(byteString);
        byteCount = byteArray.length;
        byteIndex = 0;
        var codePoints = [];
        var tmp;
        while ((tmp = decodeSymbol()) !== false) {
          codePoints.push(tmp);
        }
        return ucs2encode(codePoints);
      }

      /*--------------------------------------------------------------------------*/

      var utf8 = {
        &#x27;version&#x27;: &#x27;2.0.0&#x27;,
        &#x27;encode&#x27;: utf8encode,
        &#x27;decode&#x27;: utf8decode
      };

      // Some AMD build optimizers, like r.js, check for specific condition patterns
      // like the following:
      if (
        typeof define == &#x27;function&#x27; &amp;&amp;
        typeof define.amd == &#x27;object&#x27; &amp;&amp;
        define.amd
      ) {
        define(function() {
          return utf8;
        });
      }	else if (freeExports &amp;&amp; !freeExports.nodeType) {
        if (freeModule) { // in Node.js or RingoJS v0.8.0+
          freeModule.exports = utf8;
        } else { // in Narwhal or RingoJS v0.7.0-
          var object = {};
          var hasOwnProperty = object.hasOwnProperty;
          for (var key in utf8) {
            hasOwnProperty.call(utf8, key) &amp;&amp; (freeExports[key] = utf8[key]);
          }
        }
      } else { // in Rhino or a web browser
        root.utf8 = utf8;
      }

    }(this));

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{}],30:[function(_dereq_,module,exports){
  &#x27;use strict&#x27;;

  var alphabet = &#x27;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_&#x27;.split(&#x27;&#x27;)
    , length = 64
    , map = {}
    , seed = 0
    , i = 0
    , prev;

  /**
   * Return a string representing the specified number.
   *
   * @param {Number} num The number to convert.
   * @returns {String} The string representation of the number.
   * @api public
   */
  function encode(num) {
    var encoded = &#x27;&#x27;;

    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num &gt; 0);

    return encoded;
  }

  /**
   * Return the integer value specified by the given string.
   *
   * @param {String} str The string to convert.
   * @returns {Number} The integer value represented by the string.
   * @api public
   */
  function decode(str) {
    var decoded = 0;

    for (i = 0; i &lt; str.length; i++) {
      decoded = decoded * length + map[str.charAt(i)];
    }

    return decoded;
  }

  /**
   * Yeast: A tiny growing id generator.
   *
   * @returns {String} A unique id.
   * @api public
   */
  function yeast() {
    var now = encode(+new Date());

    if (now !== prev) return seed = 0, prev = now;
    return now +&#x27;.&#x27;+ encode(seed++);
  }

//
// Map each character to its index.
//
  for (; i &lt; length; i++) map[alphabet[i]] = i;

//
// Expose the &#x60;yeast&#x60;, &#x60;encode&#x60; and &#x60;decode&#x60; functions.
//
  yeast.encode = encode;
  yeast.decode = decode;
  module.exports = yeast;

},{}],31:[function(_dereq_,module,exports){

  /**
   * Module dependencies.
   */

  var url = _dereq_(&#x27;./url&#x27;);
  var parser = _dereq_(&#x27;socket.io-parser&#x27;);
  var Manager = _dereq_(&#x27;./manager&#x27;);
  var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client&#x27;);

  /**
   * Module exports.
   */

  module.exports = exports = lookup;

  /**
   * Managers cache.
   */

  var cache = exports.managers = {};

  /**
   * Looks up an existing &#x60;Manager&#x60; for multiplexing.
   * If the user summons:
   *
   *   &#x60;io(&#x27;http://localhost/a&#x27;);&#x60;
   *   &#x60;io(&#x27;http://localhost/b&#x27;);&#x60;
   *
   * We reuse the existing instance based on same scheme/port/host,
   * and we initialize sockets for each namespace.
   *
   * @api public
   */

  function lookup(uri, opts) {
    if (typeof uri == &#x27;object&#x27;) {
      opts = uri;
      uri = undefined;
    }

    opts = opts || {};

    var parsed = url(uri);
    var source = parsed.source;
    var id = parsed.id;
    var path = parsed.path;
    var sameNamespace = cache[id] &amp;&amp; path in cache[id].nsps;
    var newConnection = opts.forceNew || opts[&#x27;force new connection&#x27;] ||
      false === opts.multiplex || sameNamespace;

    var io;

    if (newConnection) {
      debug(&#x27;ignoring socket cache for %s&#x27;, source);
      io = Manager(source, opts);
    } else {
      if (!cache[id]) {
        debug(&#x27;new io instance for %s&#x27;, source);
        cache[id] = Manager(source, opts);
      }
      io = cache[id];
    }

    return io.socket(parsed.path);
  }

  /**
   * Protocol version.
   *
   * @api public
   */

  exports.protocol = parser.protocol;

  /**
   * &#x60;connect&#x60;.
   *
   * @param {String} uri
   * @api public
   */

  exports.connect = lookup;

  /**
   * Expose constructors for standalone build.
   *
   * @api public
   */

  exports.Manager = _dereq_(&#x27;./manager&#x27;);
  exports.Socket = _dereq_(&#x27;./socket&#x27;);

},{&quot;./manager&quot;:32,&quot;./socket&quot;:34,&quot;./url&quot;:35,&quot;debug&quot;:39,&quot;socket.io-parser&quot;:47}],32:[function(_dereq_,module,exports){

  /**
   * Module dependencies.
   */

  var eio = _dereq_(&#x27;engine.io-client&#x27;);
  var Socket = _dereq_(&#x27;./socket&#x27;);
  var Emitter = _dereq_(&#x27;component-emitter&#x27;);
  var parser = _dereq_(&#x27;socket.io-parser&#x27;);
  var on = _dereq_(&#x27;./on&#x27;);
  var bind = _dereq_(&#x27;component-bind&#x27;);
  var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client:manager&#x27;);
  var indexOf = _dereq_(&#x27;indexof&#x27;);
  var Backoff = _dereq_(&#x27;backo2&#x27;);

  /**
   * IE6+ hasOwnProperty
   */

  var has = Object.prototype.hasOwnProperty;

  /**
   * Module exports
   */

  module.exports = Manager;

  /**
   * &#x60;Manager&#x60; constructor.
   *
   * @param {String} engine instance or engine uri/opts
   * @param {Object} options
   * @api public
   */

  function Manager(uri, opts){
    if (!(this instanceof Manager)) return new Manager(uri, opts);
    if (uri &amp;&amp; (&#x27;object&#x27; == typeof uri)) {
      opts = uri;
      uri = undefined;
    }
    opts = opts || {};

    opts.path = opts.path || &#x27;/socket.io&#x27;;
    this.nsps = {};
    this.subs = [];
    this.opts = opts;
    this.reconnection(opts.reconnection !== false);
    this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
    this.reconnectionDelay(opts.reconnectionDelay || 1000);
    this.reconnectionDelayMax(opts.reconnectionDelayMax || 5000);
    this.randomizationFactor(opts.randomizationFactor || 0.5);
    this.backoff = new Backoff({
      min: this.reconnectionDelay(),
      max: this.reconnectionDelayMax(),
      jitter: this.randomizationFactor()
    });
    this.timeout(null == opts.timeout ? 20000 : opts.timeout);
    this.readyState = &#x27;closed&#x27;;
    this.uri = uri;
    this.connecting = [];
    this.lastPing = null;
    this.encoding = false;
    this.packetBuffer = [];
    this.encoder = new parser.Encoder();
    this.decoder = new parser.Decoder();
    this.autoConnect = opts.autoConnect !== false;
    if (this.autoConnect) this.open();
  }

  /**
   * Propagate given event to sockets and emit on &#x60;this&#x60;
   *
   * @api private
   */

  Manager.prototype.emitAll = function() {
    this.emit.apply(this, arguments);
    for (var nsp in this.nsps) {
      if (has.call(this.nsps, nsp)) {
        this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
      }
    }
  };

  /**
   * Update &#x60;socket.id&#x60; of all sockets
   *
   * @api private
   */

  Manager.prototype.updateSocketIds = function(){
    for (var nsp in this.nsps) {
      if (has.call(this.nsps, nsp)) {
        this.nsps[nsp].id = this.engine.id;
      }
    }
  };

  /**
   * Mix in &#x60;Emitter&#x60;.
   */

  Emitter(Manager.prototype);

  /**
   * Sets the &#x60;reconnection&#x60; config.
   *
   * @param {Boolean} true/false if it should automatically reconnect
   * @return {Manager} self or value
   * @api public
   */

  Manager.prototype.reconnection = function(v){
    if (!arguments.length) return this._reconnection;
    this._reconnection = !!v;
    return this;
  };

  /**
   * Sets the reconnection attempts config.
   *
   * @param {Number} max reconnection attempts before giving up
   * @return {Manager} self or value
   * @api public
   */

  Manager.prototype.reconnectionAttempts = function(v){
    if (!arguments.length) return this._reconnectionAttempts;
    this._reconnectionAttempts = v;
    return this;
  };

  /**
   * Sets the delay between reconnections.
   *
   * @param {Number} delay
   * @return {Manager} self or value
   * @api public
   */

  Manager.prototype.reconnectionDelay = function(v){
    if (!arguments.length) return this._reconnectionDelay;
    this._reconnectionDelay = v;
    this.backoff &amp;&amp; this.backoff.setMin(v);
    return this;
  };

  Manager.prototype.randomizationFactor = function(v){
    if (!arguments.length) return this._randomizationFactor;
    this._randomizationFactor = v;
    this.backoff &amp;&amp; this.backoff.setJitter(v);
    return this;
  };

  /**
   * Sets the maximum delay between reconnections.
   *
   * @param {Number} delay
   * @return {Manager} self or value
   * @api public
   */

  Manager.prototype.reconnectionDelayMax = function(v){
    if (!arguments.length) return this._reconnectionDelayMax;
    this._reconnectionDelayMax = v;
    this.backoff &amp;&amp; this.backoff.setMax(v);
    return this;
  };

  /**
   * Sets the connection timeout. &#x60;false&#x60; to disable
   *
   * @return {Manager} self or value
   * @api public
   */

  Manager.prototype.timeout = function(v){
    if (!arguments.length) return this._timeout;
    this._timeout = v;
    return this;
  };

  /**
   * Starts trying to reconnect if reconnection is enabled and we have not
   * started reconnecting yet
   *
   * @api private
   */

  Manager.prototype.maybeReconnectOnOpen = function() {
    // Only try to reconnect if it&#x27;s the first time we&#x27;re connecting
    if (!this.reconnecting &amp;&amp; this._reconnection &amp;&amp; this.backoff.attempts === 0) {
      // keeps reconnection from firing twice for the same reconnection loop
      this.reconnect();
    }
  };


  /**
   * Sets the current transport &#x60;socket&#x60;.
   *
   * @param {Function} optional, callback
   * @return {Manager} self
   * @api public
   */

  Manager.prototype.open =
    Manager.prototype.connect = function(fn){
      debug(&#x27;readyState %s&#x27;, this.readyState);
      if (~this.readyState.indexOf(&#x27;open&#x27;)) return this;

      debug(&#x27;opening %s&#x27;, this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self = this;
      this.readyState = &#x27;opening&#x27;;
      this.skipReconnect = false;

      // emit &#x60;open&#x60;
      var openSub = on(socket, &#x27;open&#x27;, function() {
        self.onopen();
        fn &amp;&amp; fn();
      });

      // emit &#x60;connect_error&#x60;
      var errorSub = on(socket, &#x27;error&#x27;, function(data){
        debug(&#x27;connect_error&#x27;);
        self.cleanup();
        self.readyState = &#x27;closed&#x27;;
        self.emitAll(&#x27;connect_error&#x27;, data);
        if (fn) {
          var err = new Error(&#x27;Connection error&#x27;);
          err.data = data;
          fn(err);
        } else {
          // Only do this if there is no fn to handle the error
          self.maybeReconnectOnOpen();
        }
      });

      // emit &#x60;connect_timeout&#x60;
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug(&#x27;connect attempt will timeout after %d&#x27;, timeout);

        // set timer
        var timer = setTimeout(function(){
          debug(&#x27;connect attempt timed out after %d&#x27;, timeout);
          openSub.destroy();
          socket.close();
          socket.emit(&#x27;error&#x27;, &#x27;timeout&#x27;);
          self.emitAll(&#x27;connect_timeout&#x27;, timeout);
        }, timeout);

        this.subs.push({
          destroy: function(){
            clearTimeout(timer);
          }
        });
      }

      this.subs.push(openSub);
      this.subs.push(errorSub);

      return this;
    };

  /**
   * Called upon transport open.
   *
   * @api private
   */

  Manager.prototype.onopen = function(){
    debug(&#x27;open&#x27;);

    // clear old subs
    this.cleanup();

    // mark as open
    this.readyState = &#x27;open&#x27;;
    this.emit(&#x27;open&#x27;);

    // add new subs
    var socket = this.engine;
    this.subs.push(on(socket, &#x27;data&#x27;, bind(this, &#x27;ondata&#x27;)));
    this.subs.push(on(socket, &#x27;ping&#x27;, bind(this, &#x27;onping&#x27;)));
    this.subs.push(on(socket, &#x27;pong&#x27;, bind(this, &#x27;onpong&#x27;)));
    this.subs.push(on(socket, &#x27;error&#x27;, bind(this, &#x27;onerror&#x27;)));
    this.subs.push(on(socket, &#x27;close&#x27;, bind(this, &#x27;onclose&#x27;)));
    this.subs.push(on(this.decoder, &#x27;decoded&#x27;, bind(this, &#x27;ondecoded&#x27;)));
  };

  /**
   * Called upon a ping.
   *
   * @api private
   */

  Manager.prototype.onping = function(){
    this.lastPing = new Date;
    this.emitAll(&#x27;ping&#x27;);
  };

  /**
   * Called upon a packet.
   *
   * @api private
   */

  Manager.prototype.onpong = function(){
    this.emitAll(&#x27;pong&#x27;, new Date - this.lastPing);
  };

  /**
   * Called with data.
   *
   * @api private
   */

  Manager.prototype.ondata = function(data){
    this.decoder.add(data);
  };

  /**
   * Called when parser fully decodes a packet.
   *
   * @api private
   */

  Manager.prototype.ondecoded = function(packet) {
    this.emit(&#x27;packet&#x27;, packet);
  };

  /**
   * Called upon socket error.
   *
   * @api private
   */

  Manager.prototype.onerror = function(err){
    debug(&#x27;error&#x27;, err);
    this.emitAll(&#x27;error&#x27;, err);
  };

  /**
   * Creates a new socket for the given &#x60;nsp&#x60;.
   *
   * @return {Socket}
   * @api public
   */

  Manager.prototype.socket = function(nsp){
    var socket = this.nsps[nsp];
    if (!socket) {
      socket = new Socket(this, nsp);
      this.nsps[nsp] = socket;
      var self = this;
      socket.on(&#x27;connecting&#x27;, onConnecting);
      socket.on(&#x27;connect&#x27;, function(){
        socket.id = self.engine.id;
      });

      if (this.autoConnect) {
        // manually call here since connecting evnet is fired before listening
        onConnecting();
      }
    }

    function onConnecting() {
      if (!~indexOf(self.connecting, socket)) {
        self.connecting.push(socket);
      }
    }

    return socket;
  };

  /**
   * Called upon a socket close.
   *
   * @param {Socket} socket
   */

  Manager.prototype.destroy = function(socket){
    var index = indexOf(this.connecting, socket);
    if (~index) this.connecting.splice(index, 1);
    if (this.connecting.length) return;

    this.close();
  };

  /**
   * Writes a packet.
   *
   * @param {Object} packet
   * @api private
   */

  Manager.prototype.packet = function(packet){
    debug(&#x27;writing packet %j&#x27;, packet);
    var self = this;

    if (!self.encoding) {
      // encode, then write to engine with result
      self.encoding = true;
      this.encoder.encode(packet, function(encodedPackets) {
        for (var i = 0; i &lt; encodedPackets.length; i++) {
          self.engine.write(encodedPackets[i], packet.options);
        }
        self.encoding = false;
        self.processPacketQueue();
      });
    } else { // add packet to the queue
      self.packetBuffer.push(packet);
    }
  };

  /**
   * If packet buffer is non-empty, begins encoding the
   * next packet in line.
   *
   * @api private
   */

  Manager.prototype.processPacketQueue = function() {
    if (this.packetBuffer.length &gt; 0 &amp;&amp; !this.encoding) {
      var pack = this.packetBuffer.shift();
      this.packet(pack);
    }
  };

  /**
   * Clean up transport subscriptions and packet buffer.
   *
   * @api private
   */

  Manager.prototype.cleanup = function(){
    debug(&#x27;cleanup&#x27;);

    var sub;
    while (sub = this.subs.shift()) sub.destroy();

    this.packetBuffer = [];
    this.encoding = false;
    this.lastPing = null;

    this.decoder.destroy();
  };

  /**
   * Close the current socket.
   *
   * @api private
   */

  Manager.prototype.close =
    Manager.prototype.disconnect = function(){
      debug(&#x27;disconnect&#x27;);
      this.skipReconnect = true;
      this.reconnecting = false;
      if (&#x27;opening&#x27; == this.readyState) {
        // &#x60;onclose&#x60; will not fire because
        // an open event never happened
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = &#x27;closed&#x27;;
      if (this.engine) this.engine.close();
    };

  /**
   * Called upon engine close.
   *
   * @api private
   */

  Manager.prototype.onclose = function(reason){
    debug(&#x27;onclose&#x27;);

    this.cleanup();
    this.backoff.reset();
    this.readyState = &#x27;closed&#x27;;
    this.emit(&#x27;close&#x27;, reason);

    if (this._reconnection &amp;&amp; !this.skipReconnect) {
      this.reconnect();
    }
  };

  /**
   * Attempt a reconnection.
   *
   * @api private
   */

  Manager.prototype.reconnect = function(){
    if (this.reconnecting || this.skipReconnect) return this;

    var self = this;

    if (this.backoff.attempts &gt;= this._reconnectionAttempts) {
      debug(&#x27;reconnect failed&#x27;);
      this.backoff.reset();
      this.emitAll(&#x27;reconnect_failed&#x27;);
      this.reconnecting = false;
    } else {
      var delay = this.backoff.duration();
      debug(&#x27;will wait %dms before reconnect attempt&#x27;, delay);

      this.reconnecting = true;
      var timer = setTimeout(function(){
        if (self.skipReconnect) return;

        debug(&#x27;attempting reconnect&#x27;);
        self.emitAll(&#x27;reconnect_attempt&#x27;, self.backoff.attempts);
        self.emitAll(&#x27;reconnecting&#x27;, self.backoff.attempts);

        // check again for the case socket closed in above events
        if (self.skipReconnect) return;

        self.open(function(err){
          if (err) {
            debug(&#x27;reconnect attempt error&#x27;);
            self.reconnecting = false;
            self.reconnect();
            self.emitAll(&#x27;reconnect_error&#x27;, err.data);
          } else {
            debug(&#x27;reconnect success&#x27;);
            self.onreconnect();
          }
        });
      }, delay);

      this.subs.push({
        destroy: function(){
          clearTimeout(timer);
        }
      });
    }
  };

  /**
   * Called upon successful reconnect.
   *
   * @api private
   */

  Manager.prototype.onreconnect = function(){
    var attempt = this.backoff.attempts;
    this.reconnecting = false;
    this.backoff.reset();
    this.updateSocketIds();
    this.emitAll(&#x27;reconnect&#x27;, attempt);
  };

},{&quot;./on&quot;:33,&quot;./socket&quot;:34,&quot;backo2&quot;:36,&quot;component-bind&quot;:37,&quot;component-emitter&quot;:38,&quot;debug&quot;:39,&quot;engine.io-client&quot;:1,&quot;indexof&quot;:42,&quot;socket.io-parser&quot;:47}],33:[function(_dereq_,module,exports){

  /**
   * Module exports.
   */

  module.exports = on;

  /**
   * Helper for subscriptions.
   *
   * @param {Object|EventEmitter} obj with &#x60;Emitter&#x60; mixin or &#x60;EventEmitter&#x60;
   * @param {String} event name
   * @param {Function} callback
   * @api public
   */

  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return {
      destroy: function(){
        obj.removeListener(ev, fn);
      }
    };
  }

},{}],34:[function(_dereq_,module,exports){

  /**
   * Module dependencies.
   */

  var parser = _dereq_(&#x27;socket.io-parser&#x27;);
  var Emitter = _dereq_(&#x27;component-emitter&#x27;);
  var toArray = _dereq_(&#x27;to-array&#x27;);
  var on = _dereq_(&#x27;./on&#x27;);
  var bind = _dereq_(&#x27;component-bind&#x27;);
  var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client:socket&#x27;);
  var hasBin = _dereq_(&#x27;has-binary&#x27;);

  /**
   * Module exports.
   */

  module.exports = exports = Socket;

  /**
   * Internal events (blacklisted).
   * These events can&#x27;t be emitted by the user.
   *
   * @api private
   */

  var events = {
    connect: 1,
    connect_error: 1,
    connect_timeout: 1,
    connecting: 1,
    disconnect: 1,
    error: 1,
    reconnect: 1,
    reconnect_attempt: 1,
    reconnect_failed: 1,
    reconnect_error: 1,
    reconnecting: 1,
    ping: 1,
    pong: 1
  };

  /**
   * Shortcut to &#x60;Emitter#emit&#x60;.
   */

  var emit = Emitter.prototype.emit;

  /**
   * &#x60;Socket&#x60; constructor.
   *
   * @api public
   */

  function Socket(io, nsp){
    this.io = io;
    this.nsp = nsp;
    this.json = this; // compat
    this.ids = 0;
    this.acks = {};
    this.receiveBuffer = [];
    this.sendBuffer = [];
    this.connected = false;
    this.disconnected = true;
    if (this.io.autoConnect) this.open();
  }

  /**
   * Mix in &#x60;Emitter&#x60;.
   */

  Emitter(Socket.prototype);

  /**
   * Subscribe to open, close and packet events
   *
   * @api private
   */

  Socket.prototype.subEvents = function() {
    if (this.subs) return;

    var io = this.io;
    this.subs = [
      on(io, &#x27;open&#x27;, bind(this, &#x27;onopen&#x27;)),
      on(io, &#x27;packet&#x27;, bind(this, &#x27;onpacket&#x27;)),
      on(io, &#x27;close&#x27;, bind(this, &#x27;onclose&#x27;))
    ];
  };

  /**
   * &quot;Opens&quot; the socket.
   *
   * @api public
   */

  Socket.prototype.open =
    Socket.prototype.connect = function(){
      if (this.connected) return this;

      this.subEvents();
      this.io.open(); // ensure open
      if (&#x27;open&#x27; == this.io.readyState) this.onopen();
      this.emit(&#x27;connecting&#x27;);
      return this;
    };

  /**
   * Sends a &#x60;message&#x60; event.
   *
   * @return {Socket} self
   * @api public
   */

  Socket.prototype.send = function(){
    var args = toArray(arguments);
    args.unshift(&#x27;message&#x27;);
    this.emit.apply(this, args);
    return this;
  };

  /**
   * Override &#x60;emit&#x60;.
   * If the event is in &#x60;events&#x60;, it&#x27;s emitted normally.
   *
   * @param {String} event name
   * @return {Socket} self
   * @api public
   */

  Socket.prototype.emit = function(ev){
    if (events.hasOwnProperty(ev)) {
      emit.apply(this, arguments);
      return this;
    }

    var args = toArray(arguments);
    var parserType = parser.EVENT; // default
    if (hasBin(args)) { parserType = parser.BINARY_EVENT; } // binary
    var packet = { type: parserType, data: args };

    packet.options = {};
    packet.options.compress = !this.flags || false !== this.flags.compress;

    // event ack callback
    if (&#x27;function&#x27; == typeof args[args.length - 1]) {
      debug(&#x27;emitting packet with ack id %d&#x27;, this.ids);
      this.acks[this.ids] = args.pop();
      packet.id = this.ids++;
    }

    if (this.connected) {
      this.packet(packet);
    } else {
      this.sendBuffer.push(packet);
    }

    delete this.flags;

    return this;
  };

  /**
   * Sends a packet.
   *
   * @param {Object} packet
   * @api private
   */

  Socket.prototype.packet = function(packet){
    packet.nsp = this.nsp;
    this.io.packet(packet);
  };

  /**
   * Called upon engine &#x60;open&#x60;.
   *
   * @api private
   */

  Socket.prototype.onopen = function(){
    debug(&#x27;transport is open - connecting&#x27;);

    // write connect packet if necessary
    if (&#x27;/&#x27; != this.nsp) {
      this.packet({ type: parser.CONNECT });
    }
  };

  /**
   * Called upon engine &#x60;close&#x60;.
   *
   * @param {String} reason
   * @api private
   */

  Socket.prototype.onclose = function(reason){
    debug(&#x27;close (%s)&#x27;, reason);
    this.connected = false;
    this.disconnected = true;
    delete this.id;
    this.emit(&#x27;disconnect&#x27;, reason);
  };

  /**
   * Called with socket packet.
   *
   * @param {Object} packet
   * @api private
   */

  Socket.prototype.onpacket = function(packet){
    if (packet.nsp != this.nsp) return;

    switch (packet.type) {
      case parser.CONNECT:
        this.onconnect();
        break;

      case parser.EVENT:
        this.onevent(packet);
        break;

      case parser.BINARY_EVENT:
        this.onevent(packet);
        break;

      case parser.ACK:
        this.onack(packet);
        break;

      case parser.BINARY_ACK:
        this.onack(packet);
        break;

      case parser.DISCONNECT:
        this.ondisconnect();
        break;

      case parser.ERROR:
        this.emit(&#x27;error&#x27;, packet.data);
        break;
    }
  };

  /**
   * Called upon a server event.
   *
   * @param {Object} packet
   * @api private
   */

  Socket.prototype.onevent = function(packet){
    var args = packet.data || [];
    debug(&#x27;emitting event %j&#x27;, args);

    if (null != packet.id) {
      debug(&#x27;attaching ack callback to event&#x27;);
      args.push(this.ack(packet.id));
    }

    if (this.connected) {
      emit.apply(this, args);
    } else {
      this.receiveBuffer.push(args);
    }
  };

  /**
   * Produces an ack callback to emit with an event.
   *
   * @api private
   */

  Socket.prototype.ack = function(id){
    var self = this;
    var sent = false;
    return function(){
      // prevent double callbacks
      if (sent) return;
      sent = true;
      var args = toArray(arguments);
      debug(&#x27;sending ack %j&#x27;, args);

      var type = hasBin(args) ? parser.BINARY_ACK : parser.ACK;
      self.packet({
        type: type,
        id: id,
        data: args
      });
    };
  };

  /**
   * Called upon a server acknowlegement.
   *
   * @param {Object} packet
   * @api private
   */

  Socket.prototype.onack = function(packet){
    var ack = this.acks[packet.id];
    if (&#x27;function&#x27; == typeof ack) {
      debug(&#x27;calling ack %s with %j&#x27;, packet.id, packet.data);
      ack.apply(this, packet.data);
      delete this.acks[packet.id];
    } else {
      debug(&#x27;bad ack %s&#x27;, packet.id);
    }
  };

  /**
   * Called upon server connect.
   *
   * @api private
   */

  Socket.prototype.onconnect = function(){
    this.connected = true;
    this.disconnected = false;
    this.emit(&#x27;connect&#x27;);
    this.emitBuffered();
  };

  /**
   * Emit buffered events (received and emitted).
   *
   * @api private
   */

  Socket.prototype.emitBuffered = function(){
    var i;
    for (i = 0; i &lt; this.receiveBuffer.length; i++) {
      emit.apply(this, this.receiveBuffer[i]);
    }
    this.receiveBuffer = [];

    for (i = 0; i &lt; this.sendBuffer.length; i++) {
      this.packet(this.sendBuffer[i]);
    }
    this.sendBuffer = [];
  };

  /**
   * Called upon server disconnect.
   *
   * @api private
   */

  Socket.prototype.ondisconnect = function(){
    debug(&#x27;server disconnect (%s)&#x27;, this.nsp);
    this.destroy();
    this.onclose(&#x27;io server disconnect&#x27;);
  };

  /**
   * Called upon forced client/server side disconnections,
   * this method ensures the manager stops tracking us and
   * that reconnections don&#x27;t get triggered for this.
   *
   * @api private.
   */

  Socket.prototype.destroy = function(){
    if (this.subs) {
      // clean subscriptions to avoid reconnections
      for (var i = 0; i &lt; this.subs.length; i++) {
        this.subs[i].destroy();
      }
      this.subs = null;
    }

    this.io.destroy(this);
  };

  /**
   * Disconnects the socket manually.
   *
   * @return {Socket} self
   * @api public
   */

  Socket.prototype.close =
    Socket.prototype.disconnect = function(){
      if (this.connected) {
        debug(&#x27;performing disconnect (%s)&#x27;, this.nsp);
        this.packet({ type: parser.DISCONNECT });
      }

      // remove socket from pool
      this.destroy();

      if (this.connected) {
        // fire events
        this.onclose(&#x27;io client disconnect&#x27;);
      }
      return this;
    };

  /**
   * Sets the compress flag.
   *
   * @param {Boolean} if &#x60;true&#x60;, compresses the sending data
   * @return {Socket} self
   * @api public
   */

  Socket.prototype.compress = function(compress){
    this.flags = this.flags || {};
    this.flags.compress = compress;
    return this;
  };

},{&quot;./on&quot;:33,&quot;component-bind&quot;:37,&quot;component-emitter&quot;:38,&quot;debug&quot;:39,&quot;has-binary&quot;:41,&quot;socket.io-parser&quot;:47,&quot;to-array&quot;:51}],35:[function(_dereq_,module,exports){
  (function (global){

    /**
     * Module dependencies.
     */

    var parseuri = _dereq_(&#x27;parseuri&#x27;);
    var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-client:url&#x27;);

    /**
     * Module exports.
     */

    module.exports = url;

    /**
     * URL parser.
     *
     * @param {String} url
     * @param {Object} An object meant to mimic window.location.
     *                 Defaults to window.location.
     * @api public
     */

    function url(uri, loc){
      var obj = uri;

      // default to window.location
      var loc = loc || global.location;
      if (null == uri) uri = loc.protocol + &#x27;//&#x27; + loc.host;

      // relative path support
      if (&#x27;string&#x27; == typeof uri) {
        if (&#x27;/&#x27; == uri.charAt(0)) {
          if (&#x27;/&#x27; == uri.charAt(1)) {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }

        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug(&#x27;protocol-less url %s&#x27;, uri);
          if (&#x27;undefined&#x27; != typeof loc) {
            uri = loc.protocol + &#x27;//&#x27; + uri;
          } else {
            uri = &#x27;https://&#x27; + uri;
          }
        }

        // parse
        debug(&#x27;parse %s&#x27;, uri);
        obj = parseuri(uri);
      }

      // make sure we treat &#x60;localhost:80&#x60; and &#x60;localhost&#x60; equally
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = &#x27;80&#x27;;
        }
        else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = &#x27;443&#x27;;
        }
      }

      obj.path = obj.path || &#x27;/&#x27;;

      var ipv6 = obj.host.indexOf(&#x27;:&#x27;) !== -1;
      var host = ipv6 ? &#x27;[&#x27; + obj.host + &#x27;]&#x27; : obj.host;

      // define unique id
      obj.id = obj.protocol + &#x27;://&#x27; + host + &#x27;:&#x27; + obj.port;
      // define href
      obj.href = obj.protocol + &#x27;://&#x27; + host + (loc &amp;&amp; loc.port == obj.port ? &#x27;&#x27; : (&#x27;:&#x27; + obj.port));

      return obj;
    }

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;debug&quot;:39,&quot;parseuri&quot;:45}],36:[function(_dereq_,module,exports){

  /**
   * Expose &#x60;Backoff&#x60;.
   */

  module.exports = Backoff;

  /**
   * Initialize backoff timer with &#x60;opts&#x60;.
   *
   * - &#x60;min&#x60; initial timeout in milliseconds [100]
   * - &#x60;max&#x60; max timeout [10000]
   * - &#x60;jitter&#x60; [0]
   * - &#x60;factor&#x60; [2]
   *
   * @param {Object} opts
   * @api public
   */

  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 10000;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter &gt; 0 &amp;&amp; opts.jitter &lt;= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }

  /**
   * Return the backoff duration.
   *
   * @return {Number}
   * @api public
   */

  Backoff.prototype.duration = function(){
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand =  Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) &amp; 1) == 0  ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
  };

  /**
   * Reset the number of attempts.
   *
   * @api public
   */

  Backoff.prototype.reset = function(){
    this.attempts = 0;
  };

  /**
   * Set the minimum duration
   *
   * @api public
   */

  Backoff.prototype.setMin = function(min){
    this.ms = min;
  };

  /**
   * Set the maximum duration
   *
   * @api public
   */

  Backoff.prototype.setMax = function(max){
    this.max = max;
  };

  /**
   * Set the jitter
   *
   * @api public
   */

  Backoff.prototype.setJitter = function(jitter){
    this.jitter = jitter;
  };


},{}],37:[function(_dereq_,module,exports){
  /**
   * Slice reference.
   */

  var slice = [].slice;

  /**
   * Bind &#x60;obj&#x60; to &#x60;fn&#x60;.
   *
   * @param {Object} obj
   * @param {Function|String} fn or string
   * @return {Function}
   * @api public
   */

  module.exports = function(obj, fn){
    if (&#x27;string&#x27; == typeof fn) fn = obj[fn];
    if (&#x27;function&#x27; != typeof fn) throw new Error(&#x27;bind() requires a function&#x27;);
    var args = slice.call(arguments, 2);
    return function(){
      return fn.apply(obj, args.concat(slice.call(arguments)));
    }
  };

},{}],38:[function(_dereq_,module,exports){

  /**
   * Expose &#x60;Emitter&#x60;.
   */

  module.exports = Emitter;

  /**
   * Initialize a new &#x60;Emitter&#x60;.
   *
   * @api public
   */

  function Emitter(obj) {
    if (obj) return mixin(obj);
  };

  /**
   * Mixin the emitter properties.
   *
   * @param {Object} obj
   * @return {Object}
   * @api private
   */

  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }

  /**
   * Listen on the given &#x60;event&#x60; with &#x60;fn&#x60;.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.on =
    Emitter.prototype.addEventListener = function(event, fn){
      this._callbacks = this._callbacks || {};
      (this._callbacks[&#x27;$&#x27; + event] = this._callbacks[&#x27;$&#x27; + event] || [])
        .push(fn);
      return this;
    };

  /**
   * Adds an &#x60;event&#x60; listener that will be invoked a single
   * time then automatically removed.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.once = function(event, fn){
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }

    on.fn = fn;
    this.on(event, on);
    return this;
  };

  /**
   * Remove the given callback for &#x60;event&#x60; or all
   * registered callbacks.
   *
   * @param {String} event
   * @param {Function} fn
   * @return {Emitter}
   * @api public
   */

  Emitter.prototype.off =
    Emitter.prototype.removeListener =
      Emitter.prototype.removeAllListeners =
        Emitter.prototype.removeEventListener = function(event, fn){
          this._callbacks = this._callbacks || {};

          // all
          if (0 == arguments.length) {
            this._callbacks = {};
            return this;
          }

          // specific event
          var callbacks = this._callbacks[&#x27;$&#x27; + event];
          if (!callbacks) return this;

          // remove all handlers
          if (1 == arguments.length) {
            delete this._callbacks[&#x27;$&#x27; + event];
            return this;
          }

          // remove specific handler
          var cb;
          for (var i = 0; i &lt; callbacks.length; i++) {
            cb = callbacks[i];
            if (cb === fn || cb.fn === fn) {
              callbacks.splice(i, 1);
              break;
            }
          }
          return this;
        };

  /**
   * Emit &#x60;event&#x60; with the given args.
   *
   * @param {String} event
   * @param {Mixed} ...
   * @return {Emitter}
   */

  Emitter.prototype.emit = function(event){
    this._callbacks = this._callbacks || {};
    var args = [].slice.call(arguments, 1)
      , callbacks = this._callbacks[&#x27;$&#x27; + event];

    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i &lt; len; ++i) {
        callbacks[i].apply(this, args);
      }
    }

    return this;
  };

  /**
   * Return array of callbacks for &#x60;event&#x60;.
   *
   * @param {String} event
   * @return {Array}
   * @api public
   */

  Emitter.prototype.listeners = function(event){
    this._callbacks = this._callbacks || {};
    return this._callbacks[&#x27;$&#x27; + event] || [];
  };

  /**
   * Check if this emitter has &#x60;event&#x60; handlers.
   *
   * @param {String} event
   * @return {Boolean}
   * @api public
   */

  Emitter.prototype.hasListeners = function(event){
    return !! this.listeners(event).length;
  };

},{}],39:[function(_dereq_,module,exports){
  arguments[4][17][0].apply(exports,arguments)
},{&quot;./debug&quot;:40,&quot;dup&quot;:17}],40:[function(_dereq_,module,exports){
  arguments[4][18][0].apply(exports,arguments)
},{&quot;dup&quot;:18,&quot;ms&quot;:44}],41:[function(_dereq_,module,exports){
  (function (global){

    /*
     * Module requirements.
     */

    var isArray = _dereq_(&#x27;isarray&#x27;);

    /**
     * Module exports.
     */

    module.exports = hasBinary;

    /**
     * Checks for binary data.
     *
     * Right now only Buffer and ArrayBuffer are supported..
     *
     * @param {Object} anything
     * @api public
     */

    function hasBinary(data) {

      function _hasBinary(obj) {
        if (!obj) return false;

        if ( (global.Buffer &amp;&amp; global.Buffer.isBuffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
          (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer) ||
          (global.Blob &amp;&amp; obj instanceof Blob) ||
          (global.File &amp;&amp; obj instanceof File)
        ) {
          return true;
        }

        if (isArray(obj)) {
          for (var i = 0; i &lt; obj.length; i++) {
            if (_hasBinary(obj[i])) {
              return true;
            }
          }
        } else if (obj &amp;&amp; &#x27;object&#x27; == typeof obj) {
          // see: https://github.com/Automattic/has-binary/pull/4
          if (obj.toJSON &amp;&amp; &#x27;function&#x27; == typeof obj.toJSON) {
            obj = obj.toJSON();
          }

          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key) &amp;&amp; _hasBinary(obj[key])) {
              return true;
            }
          }
        }

        return false;
      }

      return _hasBinary(data);
    }

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;isarray&quot;:43}],42:[function(_dereq_,module,exports){
  arguments[4][23][0].apply(exports,arguments)
},{&quot;dup&quot;:23}],43:[function(_dereq_,module,exports){
  arguments[4][24][0].apply(exports,arguments)
},{&quot;dup&quot;:24}],44:[function(_dereq_,module,exports){
  arguments[4][25][0].apply(exports,arguments)
},{&quot;dup&quot;:25}],45:[function(_dereq_,module,exports){
  arguments[4][28][0].apply(exports,arguments)
},{&quot;dup&quot;:28}],46:[function(_dereq_,module,exports){
  (function (global){
    /*global Blob,File*/

    /**
     * Module requirements
     */

    var isArray = _dereq_(&#x27;isarray&#x27;);
    var isBuf = _dereq_(&#x27;./is-buffer&#x27;);

    /**
     * Replaces every Buffer | ArrayBuffer in packet with a numbered placeholder.
     * Anything with blobs or files should be fed through removeBlobs before coming
     * here.
     *
     * @param {Object} packet - socket.io event packet
     * @return {Object} with deconstructed packet and list of buffers
     * @api public
     */

    exports.deconstructPacket = function(packet){
      var buffers = [];
      var packetData = packet.data;

      function _deconstructPacket(data) {
        if (!data) return data;

        if (isBuf(data)) {
          var placeholder = { _placeholder: true, num: buffers.length };
          buffers.push(data);
          return placeholder;
        } else if (isArray(data)) {
          var newData = new Array(data.length);
          for (var i = 0; i &lt; data.length; i++) {
            newData[i] = _deconstructPacket(data[i]);
          }
          return newData;
        } else if (&#x27;object&#x27; == typeof data &amp;&amp; !(data instanceof Date)) {
          var newData = {};
          for (var key in data) {
            newData[key] = _deconstructPacket(data[key]);
          }
          return newData;
        }
        return data;
      }

      var pack = packet;
      pack.data = _deconstructPacket(packetData);
      pack.attachments = buffers.length; // number of binary &#x27;attachments&#x27;
      return {packet: pack, buffers: buffers};
    };

    /**
     * Reconstructs a binary packet from its placeholder packet and buffers
     *
     * @param {Object} packet - event packet with placeholders
     * @param {Array} buffers - binary buffers to put in placeholder positions
     * @return {Object} reconstructed packet
     * @api public
     */

    exports.reconstructPacket = function(packet, buffers) {
      var curPlaceHolder = 0;

      function _reconstructPacket(data) {
        if (data &amp;&amp; data._placeholder) {
          var buf = buffers[data.num]; // appropriate buffer (should be natural order anyway)
          return buf;
        } else if (isArray(data)) {
          for (var i = 0; i &lt; data.length; i++) {
            data[i] = _reconstructPacket(data[i]);
          }
          return data;
        } else if (data &amp;&amp; &#x27;object&#x27; == typeof data) {
          for (var key in data) {
            data[key] = _reconstructPacket(data[key]);
          }
          return data;
        }
        return data;
      }

      packet.data = _reconstructPacket(packet.data);
      packet.attachments = undefined; // no longer useful
      return packet;
    };

    /**
     * Asynchronously removes Blobs or Files from data via
     * FileReader&#x27;s readAsArrayBuffer method. Used before encoding
     * data as msgpack. Calls callback with the blobless data.
     *
     * @param {Object} data
     * @param {Function} callback
     * @api private
     */

    exports.removeBlobs = function(data, callback) {
      function _removeBlobs(obj, curKey, containingObject) {
        if (!obj) return obj;

        // convert any blob
        if ((global.Blob &amp;&amp; obj instanceof Blob) ||
          (global.File &amp;&amp; obj instanceof File)) {
          pendingBlobs++;

          // async filereader
          var fileReader = new FileReader();
          fileReader.onload = function() { // this.result == arraybuffer
            if (containingObject) {
              containingObject[curKey] = this.result;
            }
            else {
              bloblessData = this.result;
            }

            // if nothing pending its callback time
            if(! --pendingBlobs) {
              callback(bloblessData);
            }
          };

          fileReader.readAsArrayBuffer(obj); // blob -&gt; arraybuffer
        } else if (isArray(obj)) { // handle array
          for (var i = 0; i &lt; obj.length; i++) {
            _removeBlobs(obj[i], i, obj);
          }
        } else if (obj &amp;&amp; &#x27;object&#x27; == typeof obj &amp;&amp; !isBuf(obj)) { // and object
          for (var key in obj) {
            _removeBlobs(obj[key], key, obj);
          }
        }
      }

      var pendingBlobs = 0;
      var bloblessData = data;
      _removeBlobs(bloblessData);
      if (!pendingBlobs) {
        callback(bloblessData);
      }
    };

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{&quot;./is-buffer&quot;:48,&quot;isarray&quot;:43}],47:[function(_dereq_,module,exports){

  /**
   * Module dependencies.
   */

  var debug = _dereq_(&#x27;debug&#x27;)(&#x27;socket.io-parser&#x27;);
  var json = _dereq_(&#x27;json3&#x27;);
  var isArray = _dereq_(&#x27;isarray&#x27;);
  var Emitter = _dereq_(&#x27;component-emitter&#x27;);
  var binary = _dereq_(&#x27;./binary&#x27;);
  var isBuf = _dereq_(&#x27;./is-buffer&#x27;);

  /**
   * Protocol version.
   *
   * @api public
   */

  exports.protocol = 4;

  /**
   * Packet types.
   *
   * @api public
   */

  exports.types = [
    &#x27;CONNECT&#x27;,
    &#x27;DISCONNECT&#x27;,
    &#x27;EVENT&#x27;,
    &#x27;BINARY_EVENT&#x27;,
    &#x27;ACK&#x27;,
    &#x27;BINARY_ACK&#x27;,
    &#x27;ERROR&#x27;
  ];

  /**
   * Packet type &#x60;connect&#x60;.
   *
   * @api public
   */

  exports.CONNECT = 0;

  /**
   * Packet type &#x60;disconnect&#x60;.
   *
   * @api public
   */

  exports.DISCONNECT = 1;

  /**
   * Packet type &#x60;event&#x60;.
   *
   * @api public
   */

  exports.EVENT = 2;

  /**
   * Packet type &#x60;ack&#x60;.
   *
   * @api public
   */

  exports.ACK = 3;

  /**
   * Packet type &#x60;error&#x60;.
   *
   * @api public
   */

  exports.ERROR = 4;

  /**
   * Packet type &#x27;binary event&#x27;
   *
   * @api public
   */

  exports.BINARY_EVENT = 5;

  /**
   * Packet type &#x60;binary ack&#x60;. For acks with binary arguments.
   *
   * @api public
   */

  exports.BINARY_ACK = 6;

  /**
   * Encoder constructor.
   *
   * @api public
   */

  exports.Encoder = Encoder;

  /**
   * Decoder constructor.
   *
   * @api public
   */

  exports.Decoder = Decoder;

  /**
   * A socket.io Encoder instance
   *
   * @api public
   */

  function Encoder() {}

  /**
   * Encode a packet as a single string if non-binary, or as a
   * buffer sequence, depending on packet type.
   *
   * @param {Object} obj - packet object
   * @param {Function} callback - function to handle encodings (likely engine.write)
   * @return Calls callback with Array of encodings
   * @api public
   */

  Encoder.prototype.encode = function(obj, callback){
    debug(&#x27;encoding packet %j&#x27;, obj);

    if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
      encodeAsBinary(obj, callback);
    }
    else {
      var encoding = encodeAsString(obj);
      callback([encoding]);
    }
  };

  /**
   * Encode packet as string.
   *
   * @param {Object} packet
   * @return {String} encoded
   * @api private
   */

  function encodeAsString(obj) {
    var str = &#x27;&#x27;;
    var nsp = false;

    // first is type
    str += obj.type;

    // attachments if we have them
    if (exports.BINARY_EVENT == obj.type || exports.BINARY_ACK == obj.type) {
      str += obj.attachments;
      str += &#x27;-&#x27;;
    }

    // if we have a namespace other than &#x60;/&#x60;
    // we append it followed by a comma &#x60;,&#x60;
    if (obj.nsp &amp;&amp; &#x27;/&#x27; != obj.nsp) {
      nsp = true;
      str += obj.nsp;
    }

    // immediately followed by the id
    if (null != obj.id) {
      if (nsp) {
        str += &#x27;,&#x27;;
        nsp = false;
      }
      str += obj.id;
    }

    // json data
    if (null != obj.data) {
      if (nsp) str += &#x27;,&#x27;;
      str += json.stringify(obj.data);
    }

    debug(&#x27;encoded %j as %s&#x27;, obj, str);
    return str;
  }

  /**
   * Encode packet as &#x27;buffer sequence&#x27; by removing blobs, and
   * deconstructing packet into object with placeholders and
   * a list of buffers.
   *
   * @param {Object} packet
   * @return {Buffer} encoded
   * @api private
   */

  function encodeAsBinary(obj, callback) {

    function writeEncoding(bloblessData) {
      var deconstruction = binary.deconstructPacket(bloblessData);
      var pack = encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;

      buffers.unshift(pack); // add packet info to beginning of data list
      callback(buffers); // write all the buffers
    }

    binary.removeBlobs(obj, writeEncoding);
  }

  /**
   * A socket.io Decoder instance
   *
   * @return {Object} decoder
   * @api public
   */

  function Decoder() {
    this.reconstructor = null;
  }

  /**
   * Mix in &#x60;Emitter&#x60; with Decoder.
   */

  Emitter(Decoder.prototype);

  /**
   * Decodes an ecoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   * @return {Object} packet
   * @api public
   */

  Decoder.prototype.add = function(obj) {
    var packet;
    if (&#x27;string&#x27; == typeof obj) {
      packet = decodeString(obj);
      if (exports.BINARY_EVENT == packet.type || exports.BINARY_ACK == packet.type) { // binary packet&#x27;s json
        this.reconstructor = new BinaryReconstructor(packet);

        // no attachments, labeled binary but no binary data to follow
        if (this.reconstructor.reconPack.attachments === 0) {
          this.emit(&#x27;decoded&#x27;, packet);
        }
      } else { // non-binary full packet
        this.emit(&#x27;decoded&#x27;, packet);
      }
    }
    else if (isBuf(obj) || obj.base64) { // raw binary data
      if (!this.reconstructor) {
        throw new Error(&#x27;got binary data when not reconstructing a packet&#x27;);
      } else {
        packet = this.reconstructor.takeBinaryData(obj);
        if (packet) { // received final buffer
          this.reconstructor = null;
          this.emit(&#x27;decoded&#x27;, packet);
        }
      }
    }
    else {
      throw new Error(&#x27;Unknown type: &#x27; + obj);
    }
  };

  /**
   * Decode a packet String (JSON data)
   *
   * @param {String} str
   * @return {Object} packet
   * @api private
   */

  function decodeString(str) {
    var p = {};
    var i = 0;

    // look up type
    p.type = Number(str.charAt(0));
    if (null == exports.types[p.type]) return error();

    // look up attachments if type binary
    if (exports.BINARY_EVENT == p.type || exports.BINARY_ACK == p.type) {
      var buf = &#x27;&#x27;;
      while (str.charAt(++i) != &#x27;-&#x27;) {
        buf += str.charAt(i);
        if (i == str.length) break;
      }
      if (buf != Number(buf) || str.charAt(i) != &#x27;-&#x27;) {
        throw new Error(&#x27;Illegal attachments&#x27;);
      }
      p.attachments = Number(buf);
    }

    // look up namespace (if any)
    if (&#x27;/&#x27; == str.charAt(i + 1)) {
      p.nsp = &#x27;&#x27;;
      while (++i) {
        var c = str.charAt(i);
        if (&#x27;,&#x27; == c) break;
        p.nsp += c;
        if (i == str.length) break;
      }
    } else {
      p.nsp = &#x27;/&#x27;;
    }

    // look up id
    var next = str.charAt(i + 1);
    if (&#x27;&#x27; !== next &amp;&amp; Number(next) == next) {
      p.id = &#x27;&#x27;;
      while (++i) {
        var c = str.charAt(i);
        if (null == c || Number(c) != c) {
          --i;
          break;
        }
        p.id += str.charAt(i);
        if (i == str.length) break;
      }
      p.id = Number(p.id);
    }

    // look up json data
    if (str.charAt(++i)) {
      try {
        p.data = json.parse(str.substr(i));
      } catch(e){
        return error();
      }
    }

    debug(&#x27;decoded %s as %j&#x27;, str, p);
    return p;
  }

  /**
   * Deallocates a parser&#x27;s resources
   *
   * @api public
   */

  Decoder.prototype.destroy = function() {
    if (this.reconstructor) {
      this.reconstructor.finishedReconstruction();
    }
  };

  /**
   * A manager of a binary event&#x27;s &#x27;buffer sequence&#x27;. Should
   * be constructed whenever a packet of type BINARY_EVENT is
   * decoded.
   *
   * @param {Object} packet
   * @return {BinaryReconstructor} initialized reconstructor
   * @api private
   */

  function BinaryReconstructor(packet) {
    this.reconPack = packet;
    this.buffers = [];
  }

  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   * @api private
   */

  BinaryReconstructor.prototype.takeBinaryData = function(binData) {
    this.buffers.push(binData);
    if (this.buffers.length == this.reconPack.attachments) { // done with buffer list
      var packet = binary.reconstructPacket(this.reconPack, this.buffers);
      this.finishedReconstruction();
      return packet;
    }
    return null;
  };

  /**
   * Cleans up binary packet reconstruction variables.
   *
   * @api private
   */

  BinaryReconstructor.prototype.finishedReconstruction = function() {
    this.reconPack = null;
    this.buffers = [];
  };

  function error(data){
    return {
      type: exports.ERROR,
      data: &#x27;parser error&#x27;
    };
  }

},{&quot;./binary&quot;:46,&quot;./is-buffer&quot;:48,&quot;component-emitter&quot;:49,&quot;debug&quot;:39,&quot;isarray&quot;:43,&quot;json3&quot;:50}],48:[function(_dereq_,module,exports){
  (function (global){

    module.exports = isBuf;

    /**
     * Returns true if obj is a buffer or an arraybuffer.
     *
     * @api private
     */

    function isBuf(obj) {
      return (global.Buffer &amp;&amp; global.Buffer.isBuffer(obj)) ||
        (global.ArrayBuffer &amp;&amp; obj instanceof ArrayBuffer);
    }

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{}],49:[function(_dereq_,module,exports){
  arguments[4][15][0].apply(exports,arguments)
},{&quot;dup&quot;:15}],50:[function(_dereq_,module,exports){
  (function (global){
    /*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
    ;(function () {
      // Detect the &#x60;define&#x60; function exposed by asynchronous module loaders. The
      // strict &#x60;define&#x60; check is necessary for compatibility with &#x60;r.js&#x60;.
      var isLoader = typeof define === &quot;function&quot; &amp;&amp; define.amd;

      // A set of types used to distinguish objects from primitives.
      var objectTypes = {
        &quot;function&quot;: true,
        &quot;object&quot;: true
      };

      // Detect the &#x60;exports&#x60; object exposed by CommonJS implementations.
      var freeExports = objectTypes[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

      // Use the &#x60;global&#x60; object exposed by Node (including Browserify via
      // &#x60;insert-module-globals&#x60;), Narwhal, and Ringo as the default context,
      // and the &#x60;window&#x60; object in browsers. Rhino exports a &#x60;global&#x60; function
      // instead.
      var root = objectTypes[typeof window] &amp;&amp; window || this,
        freeGlobal = freeExports &amp;&amp; objectTypes[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; typeof global == &quot;object&quot; &amp;&amp; global;

      if (freeGlobal &amp;&amp; (freeGlobal[&quot;global&quot;] === freeGlobal || freeGlobal[&quot;window&quot;] === freeGlobal || freeGlobal[&quot;self&quot;] === freeGlobal)) {
        root = freeGlobal;
      }

      // Public: Initializes JSON 3 using the given &#x60;context&#x60; object, attaching the
      // &#x60;stringify&#x60; and &#x60;parse&#x60; functions to the specified &#x60;exports&#x60; object.
      function runInContext(context, exports) {
        context || (context = root[&quot;Object&quot;]());
        exports || (exports = root[&quot;Object&quot;]());

        // Native constructor aliases.
        var Number = context[&quot;Number&quot;] || root[&quot;Number&quot;],
          String = context[&quot;String&quot;] || root[&quot;String&quot;],
          Object = context[&quot;Object&quot;] || root[&quot;Object&quot;],
          Date = context[&quot;Date&quot;] || root[&quot;Date&quot;],
          SyntaxError = context[&quot;SyntaxError&quot;] || root[&quot;SyntaxError&quot;],
          TypeError = context[&quot;TypeError&quot;] || root[&quot;TypeError&quot;],
          Math = context[&quot;Math&quot;] || root[&quot;Math&quot;],
          nativeJSON = context[&quot;JSON&quot;] || root[&quot;JSON&quot;];

        // Delegate to the native &#x60;stringify&#x60; and &#x60;parse&#x60; implementations.
        if (typeof nativeJSON == &quot;object&quot; &amp;&amp; nativeJSON) {
          exports.stringify = nativeJSON.stringify;
          exports.parse = nativeJSON.parse;
        }

        // Convenience aliases.
        var objectProto = Object.prototype,
          getClass = objectProto.toString,
          isProperty, forEach, undef;

        // Test the &#x60;Date#getUTC*&#x60; methods. Based on work by @Yaffle.
        var isExtended = new Date(-3509827334573292);
        try {
          // The &#x60;getUTCFullYear&#x60;, &#x60;Month&#x60;, and &#x60;Date&#x60; methods return nonsensical
          // results for certain dates in Opera &gt;= 10.53.
          isExtended = isExtended.getUTCFullYear() == -109252 &amp;&amp; isExtended.getUTCMonth() === 0 &amp;&amp; isExtended.getUTCDate() === 1 &amp;&amp;
              // Safari &lt; 2.0.2 stores the internal millisecond time value correctly,
              // but clips the values returned by the date methods to the range of
              // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
            isExtended.getUTCHours() == 10 &amp;&amp; isExtended.getUTCMinutes() == 37 &amp;&amp; isExtended.getUTCSeconds() == 6 &amp;&amp; isExtended.getUTCMilliseconds() == 708;
        } catch (exception) {}

        // Internal: Determines whether the native &#x60;JSON.stringify&#x60; and &#x60;parse&#x60;
        // implementations are spec-compliant. Based on work by Ken Snyder.
        function has(name) {
          if (has[name] !== undef) {
            // Return cached feature test result.
            return has[name];
          }
          var isSupported;
          if (name == &quot;bug-string-char-index&quot;) {
            // IE &lt;= 7 doesn&#x27;t support accessing string characters using square
            // bracket notation. IE 8 only supports this for primitives.
            isSupported = &quot;a&quot;[0] != &quot;a&quot;;
          } else if (name == &quot;json&quot;) {
            // Indicates whether both &#x60;JSON.stringify&#x60; and &#x60;JSON.parse&#x60; are
            // supported.
            isSupported = has(&quot;json-stringify&quot;) &amp;&amp; has(&quot;json-parse&quot;);
          } else {
            var value, serialized = &#x27;{&quot;a&quot;:[1,true,false,null,&quot;\\u0000\\b\\n\\f\\r\\t&quot;]}&#x27;;
            // Test &#x60;JSON.stringify&#x60;.
            if (name == &quot;json-stringify&quot;) {
              var stringify = exports.stringify, stringifySupported = typeof stringify == &quot;function&quot; &amp;&amp; isExtended;
              if (stringifySupported) {
                // A test function object with a custom &#x60;toJSON&#x60; method.
                (value = function () {
                  return 1;
                }).toJSON = value;
                try {
                  stringifySupported =
                    // Firefox 3.1b1 and b2 serialize string, number, and boolean
                    // primitives as object literals.
                    stringify(0) === &quot;0&quot; &amp;&amp;
                      // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                      // literals.
                    stringify(new Number()) === &quot;0&quot; &amp;&amp;
                    stringify(new String()) == &#x27;&quot;&quot;&#x27; &amp;&amp;
                      // FF 3.1b1, 2 throw an error if the value is &#x60;null&#x60;, &#x60;undefined&#x60;, or
                      // does not define a canonical JSON representation (this applies to
                      // objects with &#x60;toJSON&#x60; properties as well, *unless* they are nested
                      // within an object or array).
                    stringify(getClass) === undef &amp;&amp;
                      // IE 8 serializes &#x60;undefined&#x60; as &#x60;&quot;undefined&quot;&#x60;. Safari &lt;= 5.1.7 and
                      // FF 3.1b3 pass this test.
                    stringify(undef) === undef &amp;&amp;
                      // Safari &lt;= 5.1.7 and FF 3.1b3 throw &#x60;Error&#x60;s and &#x60;TypeError&#x60;s,
                      // respectively, if the value is omitted entirely.
                    stringify() === undef &amp;&amp;
                      // FF 3.1b1, 2 throw an error if the given value is not a number,
                      // string, array, object, Boolean, or &#x60;null&#x60; literal. This applies to
                      // objects with custom &#x60;toJSON&#x60; methods as well, unless they are nested
                      // inside object or array literals. YUI 3.0.0b1 ignores custom &#x60;toJSON&#x60;
                      // methods entirely.
                    stringify(value) === &quot;1&quot; &amp;&amp;
                    stringify([value]) == &quot;[1]&quot; &amp;&amp;
                      // Prototype &lt;= 1.6.1 serializes &#x60;[undefined]&#x60; as &#x60;&quot;[]&quot;&#x60; instead of
                      // &#x60;&quot;[null]&quot;&#x60;.
                    stringify([undef]) == &quot;[null]&quot; &amp;&amp;
                      // YUI 3.0.0b1 fails to serialize &#x60;null&#x60; literals.
                    stringify(null) == &quot;null&quot; &amp;&amp;
                      // FF 3.1b1, 2 halts serialization if an array contains a function:
                      // &#x60;[1, true, getClass, 1]&#x60; serializes as &quot;[1,true,],&quot;. FF 3.1b3
                      // elides non-JSON values from objects and arrays, unless they
                      // define custom &#x60;toJSON&#x60; methods.
                    stringify([undef, getClass, null]) == &quot;[null,null,null]&quot; &amp;&amp;
                      // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                      // where character escape codes are expected (e.g., &#x60;\b&#x60; =&gt; &#x60;\u0008&#x60;).
                    stringify({ &quot;a&quot;: [value, true, false, null, &quot;\x00\b\n\f\r\t&quot;] }) == serialized &amp;&amp;
                      // FF 3.1b1 and b2 ignore the &#x60;filter&#x60; and &#x60;width&#x60; arguments.
                    stringify(null, value) === &quot;1&quot; &amp;&amp;
                    stringify([1, 2], null, 1) == &quot;[\n 1,\n 2\n]&quot; &amp;&amp;
                      // JSON 2, Prototype &lt;= 1.7, and older WebKit builds incorrectly
                      // serialize extended years.
                    stringify(new Date(-8.64e15)) == &#x27;&quot;-271821-04-20T00:00:00.000Z&quot;&#x27; &amp;&amp;
                      // The milliseconds are optional in ES 5, but required in 5.1.
                    stringify(new Date(8.64e15)) == &#x27;&quot;+275760-09-13T00:00:00.000Z&quot;&#x27; &amp;&amp;
                      // Firefox &lt;= 11.0 incorrectly serializes years prior to 0 as negative
                      // four-digit years instead of six-digit years. Credits: @Yaffle.
                    stringify(new Date(-621987552e5)) == &#x27;&quot;-000001-01-01T00:00:00.000Z&quot;&#x27; &amp;&amp;
                      // Safari &lt;= 5.1.5 and Opera &gt;= 10.53 incorrectly serialize millisecond
                      // values less than 1000. Credits: @Yaffle.
                    stringify(new Date(-1)) == &#x27;&quot;1969-12-31T23:59:59.999Z&quot;&#x27;;
                } catch (exception) {
                  stringifySupported = false;
                }
              }
              isSupported = stringifySupported;
            }
            // Test &#x60;JSON.parse&#x60;.
            if (name == &quot;json-parse&quot;) {
              var parse = exports.parse;
              if (typeof parse == &quot;function&quot;) {
                try {
                  // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
                  // Conforming implementations should also coerce the initial argument to
                  // a string prior to parsing.
                  if (parse(&quot;0&quot;) === 0 &amp;&amp; !parse(false)) {
                    // Simple parsing test.
                    value = parse(serialized);
                    var parseSupported = value[&quot;a&quot;].length == 5 &amp;&amp; value[&quot;a&quot;][0] === 1;
                    if (parseSupported) {
                      try {
                        // Safari &lt;= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                        parseSupported = !parse(&#x27;&quot;\t&quot;&#x27;);
                      } catch (exception) {}
                      if (parseSupported) {
                        try {
                          // FF 4.0 and 4.0.1 allow leading &#x60;+&#x60; signs and leading
                          // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                          // certain octal literals.
                          parseSupported = parse(&quot;01&quot;) !== 1;
                        } catch (exception) {}
                      }
                      if (parseSupported) {
                        try {
                          // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                          // points. These environments, along with FF 3.1b1 and 2,
                          // also allow trailing commas in JSON objects and arrays.
                          parseSupported = parse(&quot;1.&quot;) !== 1;
                        } catch (exception) {}
                      }
                    }
                  }
                } catch (exception) {
                  parseSupported = false;
                }
              }
              isSupported = parseSupported;
            }
          }
          return has[name] = !!isSupported;
        }

        if (!has(&quot;json&quot;)) {
          // Common &#x60;[[Class]]&#x60; name aliases.
          var functionClass = &quot;[object Function]&quot;,
            dateClass = &quot;[object Date]&quot;,
            numberClass = &quot;[object Number]&quot;,
            stringClass = &quot;[object String]&quot;,
            arrayClass = &quot;[object Array]&quot;,
            booleanClass = &quot;[object Boolean]&quot;;

          // Detect incomplete support for accessing string characters by index.
          var charIndexBuggy = has(&quot;bug-string-char-index&quot;);

          // Define additional utility methods if the &#x60;Date&#x60; methods are buggy.
          if (!isExtended) {
            var floor = Math.floor;
            // A mapping between the months of the year and the number of days between
            // January 1st and the first of the respective month.
            var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
            // Internal: Calculates the number of days between the Unix epoch and the
            // first day of the given month.
            var getDay = function (year, month) {
              return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month &gt; 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
            };
          }

          // Internal: Determines if a property is a direct property of the given
          // object. Delegates to the native &#x60;Object#hasOwnProperty&#x60; method.
          if (!(isProperty = objectProto.hasOwnProperty)) {
            isProperty = function (property) {
              var members = {}, constructor;
              if ((members.__proto__ = null, members.__proto__ = {
                  // The *proto* property cannot be set multiple times in recent
                  // versions of Firefox and SeaMonkey.
                  &quot;toString&quot;: 1
                }, members).toString != getClass) {
                // Safari &lt;= 2.0.3 doesn&#x27;t implement &#x60;Object#hasOwnProperty&#x60;, but
                // supports the mutable *proto* property.
                isProperty = function (property) {
                  // Capture and break the object&#x27;s prototype chain (see section 8.6.2
                  // of the ES 5.1 spec). The parenthesized expression prevents an
                  // unsafe transformation by the Closure Compiler.
                  var original = this.__proto__, result = property in (this.__proto__ = null, this);
                  // Restore the original prototype chain.
                  this.__proto__ = original;
                  return result;
                };
              } else {
                // Capture a reference to the top-level &#x60;Object&#x60; constructor.
                constructor = members.constructor;
                // Use the &#x60;constructor&#x60; property to simulate &#x60;Object#hasOwnProperty&#x60; in
                // other environments.
                isProperty = function (property) {
                  var parent = (this.constructor || constructor).prototype;
                  return property in this &amp;&amp; !(property in parent &amp;&amp; this[property] === parent[property]);
                };
              }
              members = null;
              return isProperty.call(this, property);
            };
          }

          // Internal: Normalizes the &#x60;for...in&#x60; iteration algorithm across
          // environments. Each enumerated key is yielded to a &#x60;callback&#x60; function.
          forEach = function (object, callback) {
            var size = 0, Properties, members, property;

            // Tests for bugs in the current environment&#x27;s &#x60;for...in&#x60; algorithm. The
            // &#x60;valueOf&#x60; property inherits the non-enumerable flag from
            // &#x60;Object.prototype&#x60; in older versions of IE, Netscape, and Mozilla.
            (Properties = function () {
              this.valueOf = 0;
            }).prototype.valueOf = 0;

            // Iterate over a new instance of the &#x60;Properties&#x60; class.
            members = new Properties();
            for (property in members) {
              // Ignore all properties inherited from &#x60;Object.prototype&#x60;.
              if (isProperty.call(members, property)) {
                size++;
              }
            }
            Properties = members = null;

            // Normalize the iteration algorithm.
            if (!size) {
              // A list of non-enumerable properties inherited from &#x60;Object.prototype&#x60;.
              members = [&quot;valueOf&quot;, &quot;toString&quot;, &quot;toLocaleString&quot;, &quot;propertyIsEnumerable&quot;, &quot;isPrototypeOf&quot;, &quot;hasOwnProperty&quot;, &quot;constructor&quot;];
              // IE &lt;= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
              // properties.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, length;
                var hasProperty = !isFunction &amp;&amp; typeof object.constructor != &quot;function&quot; &amp;&amp; objectTypes[typeof object.hasOwnProperty] &amp;&amp; object.hasOwnProperty || isProperty;
                for (property in object) {
                  // Gecko &lt;= 1.0 enumerates the &#x60;prototype&#x60; property of functions under
                  // certain conditions; IE does not.
                  if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; hasProperty.call(object, property)) {
                    callback(property);
                  }
                }
                // Manually invoke the callback for each non-enumerable property.
                for (length = members.length; property = members[--length]; hasProperty.call(object, property) &amp;&amp; callback(property));
              };
            } else if (size == 2) {
              // Safari &lt;= 2.0.4 enumerates shadowed properties twice.
              forEach = function (object, callback) {
                // Create a set of iterated properties.
                var members = {}, isFunction = getClass.call(object) == functionClass, property;
                for (property in object) {
                  // Store each property name to prevent double enumeration. The
                  // &#x60;prototype&#x60; property of functions is not enumerated due to cross-
                  // environment inconsistencies.
                  if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; !isProperty.call(members, property) &amp;&amp; (members[property] = 1) &amp;&amp; isProperty.call(object, property)) {
                    callback(property);
                  }
                }
              };
            } else {
              // No bugs detected; use the standard &#x60;for...in&#x60; algorithm.
              forEach = function (object, callback) {
                var isFunction = getClass.call(object) == functionClass, property, isConstructor;
                for (property in object) {
                  if (!(isFunction &amp;&amp; property == &quot;prototype&quot;) &amp;&amp; isProperty.call(object, property) &amp;&amp; !(isConstructor = property === &quot;constructor&quot;)) {
                    callback(property);
                  }
                }
                // Manually invoke the callback for the &#x60;constructor&#x60; property due to
                // cross-environment inconsistencies.
                if (isConstructor || isProperty.call(object, (property = &quot;constructor&quot;))) {
                  callback(property);
                }
              };
            }
            return forEach(object, callback);
          };

          // Public: Serializes a JavaScript &#x60;value&#x60; as a JSON string. The optional
          // &#x60;filter&#x60; argument may specify either a function that alters how object and
          // array members are serialized, or an array of strings and numbers that
          // indicates which properties should be serialized. The optional &#x60;width&#x60;
          // argument may be either a string or number that specifies the indentation
          // level of the output.
          if (!has(&quot;json-stringify&quot;)) {
            // Internal: A map of control characters and their escaped equivalents.
            var Escapes = {
              92: &quot;\\\\&quot;,
              34: &#x27;\\&quot;&#x27;,
              8: &quot;\\b&quot;,
              12: &quot;\\f&quot;,
              10: &quot;\\n&quot;,
              13: &quot;\\r&quot;,
              9: &quot;\\t&quot;
            };

            // Internal: Converts &#x60;value&#x60; into a zero-padded string such that its
            // length is at least equal to &#x60;width&#x60;. The &#x60;width&#x60; must be &lt;= 6.
            var leadingZeroes = &quot;000000&quot;;
            var toPaddedString = function (width, value) {
              // The &#x60;|| 0&#x60; expression is necessary to work around a bug in
              // Opera &lt;= 7.54u2 where &#x60;0 == -0&#x60;, but &#x60;String(-0) !== &quot;0&quot;&#x60;.
              return (leadingZeroes + (value || 0)).slice(-width);
            };

            // Internal: Double-quotes a string &#x60;value&#x60;, replacing all ASCII control
            // characters (characters with code unit values between 0 and 31) with
            // their escaped equivalents. This is an implementation of the
            // &#x60;Quote(value)&#x60; operation defined in ES 5.1 section 15.12.3.
            var unicodePrefix = &quot;\\u00&quot;;
            var quote = function (value) {
              var result = &#x27;&quot;&#x27;, index = 0, length = value.length, useCharIndex = !charIndexBuggy || length &gt; 10;
              var symbols = useCharIndex &amp;&amp; (charIndexBuggy ? value.split(&quot;&quot;) : value);
              for (; index &lt; length; index++) {
                var charCode = value.charCodeAt(index);
                // If the character is a control character, append its Unicode or
                // shorthand escape sequence; otherwise, append the character as-is.
                switch (charCode) {
                  case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                  result += Escapes[charCode];
                  break;
                  default:
                    if (charCode &lt; 32) {
                      result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                      break;
                    }
                    result += useCharIndex ? symbols[index] : value.charAt(index);
                }
              }
              return result + &#x27;&quot;&#x27;;
            };

            // Internal: Recursively serializes an object. Implements the
            // &#x60;Str(key, holder)&#x60;, &#x60;JO(value)&#x60;, and &#x60;JA(value)&#x60; operations.
            var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
              var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
              try {
                // Necessary for host object support.
                value = object[property];
              } catch (exception) {}
              if (typeof value == &quot;object&quot; &amp;&amp; value) {
                className = getClass.call(value);
                if (className == dateClass &amp;&amp; !isProperty.call(value, &quot;toJSON&quot;)) {
                  if (value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0) {
                    // Dates are serialized according to the &#x60;Date#toJSON&#x60; method
                    // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                    // for the ISO 8601 date time string format.
                    if (getDay) {
                      // Manually compute the year, month, date, hours, minutes,
                      // seconds, and milliseconds if the &#x60;getUTC*&#x60; methods are
                      // buggy. Adapted from @Yaffle&#x27;s &#x60;date-shim&#x60; project.
                      date = floor(value / 864e5);
                      for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) &lt;= date; year++);
                      for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) &lt;= date; month++);
                      date = 1 + date - getDay(year, month);
                      // The &#x60;time&#x60; value specifies the time within the day (see ES
                      // 5.1 section 15.9.1.2). The formula &#x60;(A % B + B) % B&#x60; is used
                      // to compute &#x60;A modulo B&#x60;, as the &#x60;%&#x60; operator does not
                      // correspond to the &#x60;modulo&#x60; operation for negative numbers.
                      time = (value % 864e5 + 864e5) % 864e5;
                      // The hours, minutes, seconds, and milliseconds are obtained by
                      // decomposing the time within the day. See section 15.9.1.10.
                      hours = floor(time / 36e5) % 24;
                      minutes = floor(time / 6e4) % 60;
                      seconds = floor(time / 1e3) % 60;
                      milliseconds = time % 1e3;
                    } else {
                      year = value.getUTCFullYear();
                      month = value.getUTCMonth();
                      date = value.getUTCDate();
                      hours = value.getUTCHours();
                      minutes = value.getUTCMinutes();
                      seconds = value.getUTCSeconds();
                      milliseconds = value.getUTCMilliseconds();
                    }
                    // Serialize extended years correctly.
                    value = (year &lt;= 0 || year &gt;= 1e4 ? (year &lt; 0 ? &quot;-&quot; : &quot;+&quot;) + toPaddedString(6, year &lt; 0 ? -year : year) : toPaddedString(4, year)) +
                      &quot;-&quot; + toPaddedString(2, month + 1) + &quot;-&quot; + toPaddedString(2, date) +
                        // Months, dates, hours, minutes, and seconds should have two
                        // digits; milliseconds should have three.
                      &quot;T&quot; + toPaddedString(2, hours) + &quot;:&quot; + toPaddedString(2, minutes) + &quot;:&quot; + toPaddedString(2, seconds) +
                        // Milliseconds are optional in ES 5.0, but required in 5.1.
                      &quot;.&quot; + toPaddedString(3, milliseconds) + &quot;Z&quot;;
                  } else {
                    value = null;
                  }
                } else if (typeof value.toJSON == &quot;function&quot; &amp;&amp; ((className != numberClass &amp;&amp; className != stringClass &amp;&amp; className != arrayClass) || isProperty.call(value, &quot;toJSON&quot;))) {
                  // Prototype &lt;= 1.6.1 adds non-standard &#x60;toJSON&#x60; methods to the
                  // &#x60;Number&#x60;, &#x60;String&#x60;, &#x60;Date&#x60;, and &#x60;Array&#x60; prototypes. JSON 3
                  // ignores all &#x60;toJSON&#x60; methods on these objects unless they are
                  // defined directly on an instance.
                  value = value.toJSON(property);
                }
              }
              if (callback) {
                // If a replacement function was provided, call it to obtain the value
                // for serialization.
                value = callback.call(object, property, value);
              }
              if (value === null) {
                return &quot;null&quot;;
              }
              className = getClass.call(value);
              if (className == booleanClass) {
                // Booleans are represented literally.
                return &quot;&quot; + value;
              } else if (className == numberClass) {
                // JSON numbers must be finite. &#x60;Infinity&#x60; and &#x60;NaN&#x60; are serialized as
                // &#x60;&quot;null&quot;&#x60;.
                return value &gt; -1 / 0 &amp;&amp; value &lt; 1 / 0 ? &quot;&quot; + value : &quot;null&quot;;
              } else if (className == stringClass) {
                // Strings are double-quoted and escaped.
                return quote(&quot;&quot; + value);
              }
              // Recursively serialize objects and arrays.
              if (typeof value == &quot;object&quot;) {
                // Check for cyclic structures. This is a linear search; performance
                // is inversely proportional to the number of unique nested objects.
                for (length = stack.length; length--;) {
                  if (stack[length] === value) {
                    // Cyclic structures cannot be serialized by &#x60;JSON.stringify&#x60;.
                    throw TypeError();
                  }
                }
                // Add the object to the stack of traversed objects.
                stack.push(value);
                results = [];
                // Save the current indentation level and indent one additional level.
                prefix = indentation;
                indentation += whitespace;
                if (className == arrayClass) {
                  // Recursively serialize array elements.
                  for (index = 0, length = value.length; index &lt; length; index++) {
                    element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                    results.push(element === undef ? &quot;null&quot; : element);
                  }
                  result = results.length ? (whitespace ? &quot;[\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;]&quot; : (&quot;[&quot; + results.join(&quot;,&quot;) + &quot;]&quot;)) : &quot;[]&quot;;
                } else {
                  // Recursively serialize object members. Members are selected from
                  // either a user-specified list of property names, or the object
                  // itself.
                  forEach(properties || value, function (property) {
                    var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                    if (element !== undef) {
                      // According to ES 5.1 section 15.12.3: &quot;If &#x60;gap&#x60; {whitespace}
                      // is not the empty string, let &#x60;member&#x60; {quote(property) + &quot;:&quot;}
                      // be the concatenation of &#x60;member&#x60; and the &#x60;space&#x60; character.&quot;
                      // The &quot;&#x60;space&#x60; character&quot; refers to the literal space
                      // character, not the &#x60;space&#x60; {width} argument provided to
                      // &#x60;JSON.stringify&#x60;.
                      results.push(quote(property) + &quot;:&quot; + (whitespace ? &quot; &quot; : &quot;&quot;) + element);
                    }
                  });
                  result = results.length ? (whitespace ? &quot;{\n&quot; + indentation + results.join(&quot;,\n&quot; + indentation) + &quot;\n&quot; + prefix + &quot;}&quot; : (&quot;{&quot; + results.join(&quot;,&quot;) + &quot;}&quot;)) : &quot;{}&quot;;
                }
                // Remove the object from the traversed object stack.
                stack.pop();
                return result;
              }
            };

            // Public: &#x60;JSON.stringify&#x60;. See ES 5.1 section 15.12.3.
            exports.stringify = function (source, filter, width) {
              var whitespace, callback, properties, className;
              if (objectTypes[typeof filter] &amp;&amp; filter) {
                if ((className = getClass.call(filter)) == functionClass) {
                  callback = filter;
                } else if (className == arrayClass) {
                  // Convert the property names array into a makeshift set.
                  properties = {};
                  for (var index = 0, length = filter.length, value; index &lt; length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) &amp;&amp; (properties[value] = 1));
                }
              }
              if (width) {
                if ((className = getClass.call(width)) == numberClass) {
                  // Convert the &#x60;width&#x60; to an integer and create a string containing
                  // &#x60;width&#x60; number of space characters.
                  if ((width -= width % 1) &gt; 0) {
                    for (whitespace = &quot;&quot;, width &gt; 10 &amp;&amp; (width = 10); whitespace.length &lt; width; whitespace += &quot; &quot;);
                  }
                } else if (className == stringClass) {
                  whitespace = width.length &lt;= 10 ? width : width.slice(0, 10);
                }
              }
              // Opera &lt;= 7.54u2 discards the values associated with empty string keys
              // (&#x60;&quot;&quot;&#x60;) only if they are used directly within an object member list
              // (e.g., &#x60;!(&quot;&quot; in { &quot;&quot;: 1})&#x60;).
              return serialize(&quot;&quot;, (value = {}, value[&quot;&quot;] = source, value), callback, properties, whitespace, &quot;&quot;, []);
            };
          }

          // Public: Parses a JSON source string.
          if (!has(&quot;json-parse&quot;)) {
            var fromCharCode = String.fromCharCode;

            // Internal: A map of escaped control characters and their unescaped
            // equivalents.
            var Unescapes = {
              92: &quot;\\&quot;,
              34: &#x27;&quot;&#x27;,
              47: &quot;/&quot;,
              98: &quot;\b&quot;,
              116: &quot;\t&quot;,
              110: &quot;\n&quot;,
              102: &quot;\f&quot;,
              114: &quot;\r&quot;
            };

            // Internal: Stores the parser state.
            var Index, Source;

            // Internal: Resets the parser state and throws a &#x60;SyntaxError&#x60;.
            var abort = function () {
              Index = Source = null;
              throw SyntaxError();
            };

            // Internal: Returns the next token, or &#x60;&quot;$&quot;&#x60; if the parser has reached
            // the end of the source string. A token may be a string, number, &#x60;null&#x60;
            // literal, or Boolean literal.
            var lex = function () {
              var source = Source, length = source.length, value, begin, position, isSigned, charCode;
              while (Index &lt; length) {
                charCode = source.charCodeAt(Index);
                switch (charCode) {
                  case 9: case 10: case 13: case 32:
                  // Skip whitespace tokens, including tabs, carriage returns, line
                  // feeds, and space characters.
                  Index++;
                  break;
                  case 123: case 125: case 91: case 93: case 58: case 44:
                  // Parse a punctuator token (&#x60;{&#x60;, &#x60;}&#x60;, &#x60;[&#x60;, &#x60;]&#x60;, &#x60;:&#x60;, or &#x60;,&#x60;) at
                  // the current position.
                  value = charIndexBuggy ? source.charAt(Index) : source[Index];
                  Index++;
                  return value;
                  case 34:
                    // &#x60;&quot;&#x60; delimits a JSON string; advance to the next character and
                    // begin parsing the string. String tokens are prefixed with the
                    // sentinel &#x60;@&#x60; character to distinguish them from punctuators and
                    // end-of-string tokens.
                    for (value = &quot;@&quot;, Index++; Index &lt; length;) {
                      charCode = source.charCodeAt(Index);
                      if (charCode &lt; 32) {
                        // Unescaped ASCII control characters (those with a code unit
                        // less than the space character) are not permitted.
                        abort();
                      } else if (charCode == 92) {
                        // A reverse solidus (&#x60;\&#x60;) marks the beginning of an escaped
                        // control character (including &#x60;&quot;&#x60;, &#x60;\&#x60;, and &#x60;/&#x60;) or Unicode
                        // escape sequence.
                        charCode = source.charCodeAt(++Index);
                        switch (charCode) {
                          case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                          // Revive escaped control characters.
                          value += Unescapes[charCode];
                          Index++;
                          break;
                          case 117:
                            // &#x60;\u&#x60; marks the beginning of a Unicode escape sequence.
                            // Advance to the first character and validate the
                            // four-digit code point.
                            begin = ++Index;
                            for (position = Index + 4; Index &lt; position; Index++) {
                              charCode = source.charCodeAt(Index);
                              // A valid sequence comprises four hexdigits (case-
                              // insensitive) that form a single hexadecimal value.
                              if (!(charCode &gt;= 48 &amp;&amp; charCode &lt;= 57 || charCode &gt;= 97 &amp;&amp; charCode &lt;= 102 || charCode &gt;= 65 &amp;&amp; charCode &lt;= 70)) {
                                // Invalid Unicode escape sequence.
                                abort();
                              }
                            }
                            // Revive the escaped character.
                            value += fromCharCode(&quot;0x&quot; + source.slice(begin, Index));
                            break;
                          default:
                            // Invalid escape sequence.
                            abort();
                        }
                      } else {
                        if (charCode == 34) {
                          // An unescaped double-quote character marks the end of the
                          // string.
                          break;
                        }
                        charCode = source.charCodeAt(Index);
                        begin = Index;
                        // Optimize for the common case where a string is valid.
                        while (charCode &gt;= 32 &amp;&amp; charCode != 92 &amp;&amp; charCode != 34) {
                          charCode = source.charCodeAt(++Index);
                        }
                        // Append the string as-is.
                        value += source.slice(begin, Index);
                      }
                    }
                    if (source.charCodeAt(Index) == 34) {
                      // Advance to the next character and return the revived string.
                      Index++;
                      return value;
                    }
                    // Unterminated string.
                    abort();
                  default:
                    // Parse numbers and literals.
                    begin = Index;
                    // Advance past the negative sign, if one is specified.
                    if (charCode == 45) {
                      isSigned = true;
                      charCode = source.charCodeAt(++Index);
                    }
                    // Parse an integer or floating-point value.
                    if (charCode &gt;= 48 &amp;&amp; charCode &lt;= 57) {
                      // Leading zeroes are interpreted as octal literals.
                      if (charCode == 48 &amp;&amp; ((charCode = source.charCodeAt(Index + 1)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57)) {
                        // Illegal octal literal.
                        abort();
                      }
                      isSigned = false;
                      // Parse the integer component.
                      for (; Index &lt; length &amp;&amp; ((charCode = source.charCodeAt(Index)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); Index++);
                      // Floats cannot contain a leading decimal point; however, this
                      // case is already accounted for by the parser.
                      if (source.charCodeAt(Index) == 46) {
                        position = ++Index;
                        // Parse the decimal component.
                        for (; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                        if (position == Index) {
                          // Illegal trailing decimal.
                          abort();
                        }
                        Index = position;
                      }
                      // Parse exponents. The &#x60;e&#x60; denoting the exponent is
                      // case-insensitive.
                      charCode = source.charCodeAt(Index);
                      if (charCode == 101 || charCode == 69) {
                        charCode = source.charCodeAt(++Index);
                        // Skip past the sign following the exponent, if one is
                        // specified.
                        if (charCode == 43 || charCode == 45) {
                          Index++;
                        }
                        // Parse the exponential component.
                        for (position = Index; position &lt; length &amp;&amp; ((charCode = source.charCodeAt(position)), charCode &gt;= 48 &amp;&amp; charCode &lt;= 57); position++);
                        if (position == Index) {
                          // Illegal empty exponent.
                          abort();
                        }
                        Index = position;
                      }
                      // Coerce the parsed value to a JavaScript number.
                      return +source.slice(begin, Index);
                    }
                    // A negative sign may only precede numbers.
                    if (isSigned) {
                      abort();
                    }
                    // &#x60;true&#x60;, &#x60;false&#x60;, and &#x60;null&#x60; literals.
                    if (source.slice(Index, Index + 4) == &quot;true&quot;) {
                      Index += 4;
                      return true;
                    } else if (source.slice(Index, Index + 5) == &quot;false&quot;) {
                      Index += 5;
                      return false;
                    } else if (source.slice(Index, Index + 4) == &quot;null&quot;) {
                      Index += 4;
                      return null;
                    }
                    // Unrecognized token.
                    abort();
                }
              }
              // Return the sentinel &#x60;$&#x60; character if the parser has reached the end
              // of the source string.
              return &quot;$&quot;;
            };

            // Internal: Parses a JSON &#x60;value&#x60; token.
            var get = function (value) {
              var results, hasMembers;
              if (value == &quot;$&quot;) {
                // Unexpected end of input.
                abort();
              }
              if (typeof value == &quot;string&quot;) {
                if ((charIndexBuggy ? value.charAt(0) : value[0]) == &quot;@&quot;) {
                  // Remove the sentinel &#x60;@&#x60; character.
                  return value.slice(1);
                }
                // Parse object and array literals.
                if (value == &quot;[&quot;) {
                  // Parses a JSON array, returning a new JavaScript array.
                  results = [];
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex();
                    // A closing square bracket marks the end of the array literal.
                    if (value == &quot;]&quot;) {
                      break;
                    }
                    // If the array literal contains elements, the current token
                    // should be a comma separating the previous element from the
                    // next.
                    if (hasMembers) {
                      if (value == &quot;,&quot;) {
                        value = lex();
                        if (value == &quot;]&quot;) {
                          // Unexpected trailing &#x60;,&#x60; in array literal.
                          abort();
                        }
                      } else {
                        // A &#x60;,&#x60; must separate each array element.
                        abort();
                      }
                    }
                    // Elisions and leading commas are not permitted.
                    if (value == &quot;,&quot;) {
                      abort();
                    }
                    results.push(get(value));
                  }
                  return results;
                } else if (value == &quot;{&quot;) {
                  // Parses a JSON object, returning a new JavaScript object.
                  results = {};
                  for (;; hasMembers || (hasMembers = true)) {
                    value = lex();
                    // A closing curly brace marks the end of the object literal.
                    if (value == &quot;}&quot;) {
                      break;
                    }
                    // If the object literal contains members, the current token
                    // should be a comma separator.
                    if (hasMembers) {
                      if (value == &quot;,&quot;) {
                        value = lex();
                        if (value == &quot;}&quot;) {
                          // Unexpected trailing &#x60;,&#x60; in object literal.
                          abort();
                        }
                      } else {
                        // A &#x60;,&#x60; must separate each object member.
                        abort();
                      }
                    }
                    // Leading commas are not permitted, object property names must be
                    // double-quoted strings, and a &#x60;:&#x60; must separate each property
                    // name and value.
                    if (value == &quot;,&quot; || typeof value != &quot;string&quot; || (charIndexBuggy ? value.charAt(0) : value[0]) != &quot;@&quot; || lex() != &quot;:&quot;) {
                      abort();
                    }
                    results[value.slice(1)] = get(lex());
                  }
                  return results;
                }
                // Unexpected token encountered.
                abort();
              }
              return value;
            };

            // Internal: Updates a traversed object member.
            var update = function (source, property, callback) {
              var element = walk(source, property, callback);
              if (element === undef) {
                delete source[property];
              } else {
                source[property] = element;
              }
            };

            // Internal: Recursively traverses a parsed JSON object, invoking the
            // &#x60;callback&#x60; function for each value. This is an implementation of the
            // &#x60;Walk(holder, name)&#x60; operation defined in ES 5.1 section 15.12.2.
            var walk = function (source, property, callback) {
              var value = source[property], length;
              if (typeof value == &quot;object&quot; &amp;&amp; value) {
                // &#x60;forEach&#x60; can&#x27;t be used to traverse an array in Opera &lt;= 8.54
                // because its &#x60;Object#hasOwnProperty&#x60; implementation returns &#x60;false&#x60;
                // for array indices (e.g., &#x60;![1, 2, 3].hasOwnProperty(&quot;0&quot;)&#x60;).
                if (getClass.call(value) == arrayClass) {
                  for (length = value.length; length--;) {
                    update(value, length, callback);
                  }
                } else {
                  forEach(value, function (property) {
                    update(value, property, callback);
                  });
                }
              }
              return callback.call(source, property, value);
            };

            // Public: &#x60;JSON.parse&#x60;. See ES 5.1 section 15.12.2.
            exports.parse = function (source, callback) {
              var result, value;
              Index = 0;
              Source = &quot;&quot; + source;
              result = get(lex());
              // If a JSON string contains multiple tokens, it is invalid.
              if (lex() != &quot;$&quot;) {
                abort();
              }
              // Reset the parser state.
              Index = Source = null;
              return callback &amp;&amp; getClass.call(callback) == functionClass ? walk((value = {}, value[&quot;&quot;] = result, value), &quot;&quot;, callback) : result;
            };
          }
        }

        exports[&quot;runInContext&quot;] = runInContext;
        return exports;
      }

      if (freeExports &amp;&amp; !isLoader) {
        // Export for CommonJS environments.
        runInContext(root, freeExports);
      } else {
        // Export for web browsers and JavaScript engines.
        var nativeJSON = root.JSON,
          previousJSON = root[&quot;JSON3&quot;],
          isRestored = false;

        var JSON3 = runInContext(root, (root[&quot;JSON3&quot;] = {
          // Public: Restores the original value of the global &#x60;JSON&#x60; object and
          // returns a reference to the &#x60;JSON3&#x60; object.
          &quot;noConflict&quot;: function () {
            if (!isRestored) {
              isRestored = true;
              root.JSON = nativeJSON;
              root[&quot;JSON3&quot;] = previousJSON;
              nativeJSON = previousJSON = null;
            }
            return JSON3;
          }
        }));

        root.JSON = {
          &quot;parse&quot;: JSON3.parse,
          &quot;stringify&quot;: JSON3.stringify
        };
      }

      // Export for asynchronous module loaders.
      if (isLoader) {
        define(function () {
          return JSON3;
        });
      }
    }).call(this);

  }).call(this,typeof self !== &quot;undefined&quot; ? self : typeof window !== &quot;undefined&quot; ? window : typeof global !== &quot;undefined&quot; ? global : {})
},{}],51:[function(_dereq_,module,exports){
  module.exports = toArray

  function toArray(list, index) {
    var array = []

    index = index || 0

    for (var i = index || 0; i &lt; list.length; i++) {
      array[i - index] = list[i]
    }

    return array
  }

},{}]},{},[31])(31)
});

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
